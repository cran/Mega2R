<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>1 Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>1 Introduction</h1>

<h2>1.1 What is Mega2</h2>

<p>The Mega2R package uses as input genetic data that have been reformatted and stored in a &#39;SQLite&#39; database; this database is initially created by the standalone Mega2 C++ program.  Here we give a quick overview of the Mega2 C++ program.  For more information, please see the Mega2 documentation, which is available here:  <a href="https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html">https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html</a></p>

<p>During an association or linkage analysis project, one may need to
analyze the data with several different programs. Unfortunately, it
can often be quite difficult to get one&#39;s data in the proper format
desired by each different computer program. Not only must the data be
converted to the proper format, but also the loci must be reordered
into their proper order. Writing custom reformatting scripts can be
error-prone and very time-consuming. To address these problems, we
created Mega2.  </p>

<p>Mega2 can read input data in several formats: LINKAGE format, PLINK
format, IMPUTE format and VCF format.  Mega2 allows one to augment these input
formats with additional information, if desired. For example, trait
locus penetrance information can be specified. The input data are read
and validated once, then stored in a &#39;SQLite&#39; database file.</p>

<p>Mega2 then takes the database file and, via a menu-driven interface,
transforms it into various other file formats, thus greatly facilitating a variety of
different analyses. In addition, for many of these options, it also
sets up a shell script that then can automatically run these analyses
(if you are using Mega2 in a Unix or Macintosh environment).</p>

<p>Mega2 is currently structured so that the user proceeds through a
series of menus, both to create the database and later to process it,
making choices in each menu (or accepting the default values), until
the desired output files are created. After the desired output files
are created, Mega2 exits. Mega2 can also be run in a hands-free
mode, using a control or &#39;batch&#39; file to specify these choices.</p>

<p>In addition to the ability to reformat data for a variety of analysis
programs, other useful features of Mega2 include:</p>

<ol>
<li><p>The ability to create publication-quality PDF plots of the results using our nplplot library.</p></li>
<li><p>The ability to create custom tracks of results for visualization in the UCSC genome browser.</p></li>
<li><p>The ability to run in an automated way using batch files.</p></li>
<li><p>The availability of our Genetic Map Interpolator for aiding in constructing genetic maps of markers.</p></li>
<li><p>The ability to align allele labels to a reference and to resolve strand issues. </p></li>
<li><p>The ability to simulate genotype errors.</p></li>
<li><p>Input and output support for Mega2 format files that contain informative header lines and are readable into R.</p></li>
<li><p>Input and output support for the widely-used PLINK format files.</p></li>
<li><p>Input and output support for Variant Call Format (VCF, BCF, compressed VCF) files, including flexible filtering on input.</p></li>
<li><p>Input support for IMPUTE2 GEN format files and binary IMPUTE2 BGEN format files.</p></li>
<li><p>The ability to automatically zero out selected genotypes for specific individuals in order to resolve Mendelian inconsistencies.</p></li>
<li><p>In most cases, in addition to generating appropriately re-formatted files, Mega2 also generates a shell script that will automatically run the desired program. </p></li>
<li><p>Creation of an HTML summary of the most recent run of Mega2, with links to input and output and log files.</p></li>
<li><p>Creation of extensive data analysis logs, both during database creation: (files MEGA2.DB.LOG and MEGA2.DB.ERR) and during each analysis: (files MEGA2.LOG and MEGA2.ERR).</p></li>
</ol>

<p>The features listed above and the documentation, <a href="https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html">https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html</a>, describe the
Mega2 executable, written in C++.  The site
<a href="https://watson.hgen.pitt.edu/register/">https://watson.hgen.pitt.edu/register/</a> provides Mega2 binaries for a number
of different platforms including Windows 7 and 10 as well as the GPL-3
source.  (The source for Mega2 as well as Mega2R can be found at
<a href="https://bitbucket.org/dweeks/mega2">https://bitbucket.org/dweeks/mega2</a> BitBucket site.)</p>

<h2>1.2 What is Mega2R</h2>

<p>Since Mega2 now produces a &#39;SQLite&#39; database, it is now easy to load
the data that Mega2 has processed into R.  This is what Mega2R and
this tutorial is all about.  </p>

<p>Mega2R loads and manipulates data frames containing genotype, 
phenotype, and family information from the input &#39;SQLite&#39; database. In
addition, we have developed C++ functions to decompress needed
subsets of the genotype data, on the fly, in a memory efficient manner.<br/>
We have also created several more functions that
illustrate how to use the data frames as well as perform useful
functions: these permit one to run the &#39;pedgene&#39; package (<a href="https://CRAN.R-project.org/package=pedgene">https://CRAN.R-project.org/package=pedgene</a>) to carry
out gene-based association tests on family data using selected
marker subsets, to run the &#39;SKAT&#39; package (<a href="https://CRAN.R-project.org/package=SKAT">https://CRAN.R-project.org/package=SKAT</a>) to carry out gene-based
association tests using selected marker subsets, to output subsets of the Mega2R data as a VCF file (<a href="https://github.com/samtools/hts-specs">https://github.com/samtools/hts-specs</a>) and
related files (for phenotype and family data), and to convert the
data frames into &#39;GenABEL&#39; gwaa.data-class objects (<a href="https://CRAN.R-project.org/package=GenABEL">https://CRAN.R-project.org/package=GenABEL</a>).</p>

<p>This tutorial shows how to read the &#39;SQLite&#39;
database and how to access tables in it using this package, Mega2R.
The tutorial shows how to carry out gene-based analyses that select subsets
of the data that corresponds to transcripts or other base pair ranges.<br/>
It is important to point out that
like GenABEL (<a href="https://CRAN.R-project.org/package=GenABEL">https://CRAN.R-project.org/package=GenABEL</a>),
Mega2R keeps its genotype data in a compressed format that is only expanded
when needed.  </p>

<h1>2 Example Genome-wide Association Data</h1>

<p>We used the SeqSIMLA2 program to generate an example data set to use in this vignette.
[SeqSIMLA2: simulating correlated quantitative traits accounting for shared
environmental effects in user-specified pedigree structure, Chung RH1,
Tsai WY, Hsieh CH, Hung KY, Hsiung CA, Hauser ER., Genet Epidemiol.
2015 Jan;39(1):20-4. doi: 10.1002/gepi.21850. Epub 2014 Sep 22.]
We needed to sub-sample the data down to 1,380 people and 1,000
markers to make the size manageable. These data will be used to
illustrate Mega2 and Mega2R operations that follow.</p>

<p>Note: The simulator produces markers on only chromosome 1.</p>

<h1>3 Tutorial Data</h1>

<p>The files you will need for this tutorial are provided in this package.
Further, our use of the &ldquo;mega2&rdquo; executable expects the Mega2.BATCH.<name> files to be in the
working directory and the latter files expect their data files to be in the
working directory.  This is done by running:</p>

<pre><code class="r">library(Mega2R)
dump_mega2rtutorial_data()
</code></pre>

<p>All the files for this vignette will be created in the temporary directory given by <code>file.path(tempdir(),&quot;Mega2Rtutorial&quot;)</code>.
In that directory, you will see the following files:  </p>

<pre><code class="r">list.files(where_mega2rtutorial_data())
</code></pre>

<pre><code>##  [1] &quot;MEGA2.BATCH.seqsimr&quot; &quot;MEGA2.BATCH.srdta&quot;   &quot;MEGA2.BATCH.vcf&quot;    
##  [4] &quot;Mega2r.map&quot;          &quot;Mega2r.map.gz&quot;       &quot;Mega2r.ped&quot;         
##  [7] &quot;Mega2r.ped.gz&quot;       &quot;seqsimr.db&quot;          &quot;seqsimr.db.gz&quot;      
## [10] &quot;srdta.db&quot;            &quot;srdta.db.gz&quot;
</code></pre>

<p>*<em>Note: The temporary directory name, given by <code>file.path(tempdir(),&quot;Mega2Rtutorial&quot;)</code>, is generated randomly each time this
vignette is run. *</em></p>

<p><strong>Note:  The temporary directory name is also the value of the R expression, <code>where_mega2rtutorial_data()</code>.</strong></p>

<p>When you are done with these exercise, the &ldquo;clean&rdquo; command will remove these files:</p>

<pre><code class="r">clean_mega2rtutorial_data()
</code></pre>

<h1>4 Installation</h1>

<h2>4.1 R</h2>

<p><strong>We will assume that you have started an session at which to type the commands
in the tutorial.</strong></p>

<p>To run any of these exercises, you should install the package Mega2R.</p>

<pre><code class="r">install.packages(&quot;Mega2R&quot;)
</code></pre>

<h2>4.2 Bioconductor</h2>

<p>In Section 6 below, we will carry out gene-based association tests, where &#39;genes&#39; are defined according to a database containing the boundaries of the gene transcripts.
This requires two Bioconductor Annotations databases to be installed.
The first line (below) loads the Bioconductor loader and the next
two lines install two annotation databases. One annotation database provides the gene transcript
locations and the other maps gene names to entrez gene IDs. (Note: As described in Section 5.3.3,
you may choose a different transcript database from Bioconductor or
construct one of your own.) Please type in R:</p>

<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)

biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)
</code></pre>

<p>The above step is run once.</p>

<h1>5 Using Mega2R to access and process genetic data</h1>

<h2>5.1 Creating a Mega2 database</h2>

<p>We have provided files in this package that contain
the data from the simulation. These files are in PLINK ped format data:</p>

<ul>
<li>Mega2r.ped</li>
<li>Mega2r.map</li>
</ul>

<p><strong>If you do not wish to install Mega2 right now, you can use the seqsimr.db
database that is in the tutorial directory.</strong></p>

<p>You can obtain the Mega2 program from
<a href="https://watson.hgen.pitt.edu/register/">https://watson.hgen.pitt.edu/register/</a>. Then, you will invoke Mega2
on your data. To make matters simple, we will use a pre-constructed
Mega2 batch file to automate the processing by Mega2. To run Mega2 to
process and create the &#39;SQLite&#39; database &#39;seqsimr.db&#39;, we issue the following
command at the Unix prompt in the directory containing tutorial data; the name of this directory is given by the R command:
<code>where_mega2rtutorial_data()</code></p>

<pre><code class="bash">mega2 MEGA2.BATCH.seqsimr
</code></pre>

<p><strong>Note: This vignette will not invoke <em>mega2</em>, but use the seqsimr.db
database that is in this package.</strong></p>

<p><strong>NOTE: To make this tutorial only dependent on R, the above code is not actually run.  And its
results, shown below, were captured from an environment where we had both R and Mega2 executable
available.  All the examples of mega2 shown in these exercises have been similarly &ldquo;fudged&rdquo;.</strong></p>

<p>The output seen on the screen when we ran Mega2 to create the &#39;SQLite&#39; database is as follows:</p>

<pre><code>## ==========================================================
##                           MEGA2 4.9.2
##
##      Copyright 1999-2017, University of Pittsburgh. All Rights Reserved.
##
##      Contributors to Mega2: Robert Baron, Justin R. Stickel, Charles P. Kollar, 
##      Nandita Mukhopadhyay, Lee Almasy, Mark Schroeder, William P. Mulvihill, 
##      and Daniel E. Weeks. 
## 
##      Last updated: Jun 13 2017, 09:36:42 , valid until June 15, 2018.
##      Compiled with gcc version 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)
## 
##      Mega2 comes with ABSOLUTELY NO WARRANTY.
##      See LICENSE.txt for terms of copying, modifying &amp; redistributing Mega2.
## ==========================================================
## NOTE: For humans, chromosome 23 codes for X, 24 codes for Y and 25 codes for XY.
## 
## Run date:                  2017-7-24-10-03
## 
## Running Mega2 in batch mode from MEGA2.BATCH.seqsimr.
## Input filenames and missing value indicator read in from batch file.
## Dump Analysis option read in from batch file.
## WARNING: Locus selections not specified in batch file.
## WARNING: Going to Reorder menu.
## WARNING: Trait selections not specified in batch file.
## WARNING: Going to Trait selection menu.
## ==========================================================
## Keyword Input_Locus_File not in batch file, Locus file assumed to be unspecified.
## Keyword Input_Map_File not in batch file, Map file assumed to be unspecified.
## Keyword Input_Omit_File not in batch file, Omit file assumed to be unspecified.
## Keyword Input_Frequency_File not in batch file, Frequency file assumed to be unspecified.
## Keyword Input_Penetrance_File not in batch file, Penetrance file assumed to be unspecified.
## Keyword Input_Aux_File not in batch file, Aux file assumed to be unspecified.
## Keyword Input_Phenotype_File not in batch file, Phenotype file assumed to be unspecified.
## Keyword Input_Imputed_Info_File not in batch file, Imputed Info file assumed to be unspecified.
## ===========================================================
## Analysis Class: Dump.
## Quantitative  Input Missing Value  -9 
## Affection     Input Missing Value     &quot;-9&quot;
## Quantitative Output Missing Value      &quot;*&quot;
## Affection    Output Missing Value      &quot;*&quot;
## Input Format: PLINK PED format (ped)
## Pedigree and map files specified as PLINK format.
## omit, penetrance, and frequency files are always in Mega2 format.
## Input files will be read in as PLINK or Mega2 format files as appropriate.
## Reading PLINK map file for names: Mega2r.map
## Reading map file Mega2r.map ... (4 columns)
## Input Map name: Map, type: average genetic map, units: kosambi centiMorgans
## Input Map name: BP, type: physical map
## Found 2 possible maps in the Mega2r.map file.
## Now checking each record in map file Mega2r.map ...
## Done reading map file: Mega2r.map
## 
## ===========================================================
## Total number of loci =  1001
## 1 trait locus 
##       1 Affection status locus: 
##                 default
##       1000 Marker loci 
## Number of loci found per chromosome (chromosome:number)
##    1:1000
## ===========================================================
## WARNING: No frequency file provided.
## WARNING: Allele frequencies for these will be estimated from data.
## Trait &#39;default&#39; will be assigned the default penetrance: (0.0500 0.9000 0.9000)
## Reading PLINK .ped file: Mega2r.ped (2006 columns).
## 1000 (of 1000) markers to be included from Mega2r.map
## Reading pedigree information from Mega2r.ped
## 1380 individuals read from Mega2r.ped
## 1380 individuals with nonmissing phenotypes
## 105 cases, 1275 controls, 0 missing
## 620 males, 760 females, 0 of unspecified sex
## 0 founders, 1380 non-founders found
## ===========================================================
## Input pedigree data contains:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Pedigree exclusion option : Include all pedigrees whether typed or not.
## Count option: all alleles
## Count half-typed individuals&#39; alleles : no 
## ===========================================================
## Recoding pedigree genotypes ... 
## ===========================================================
## Pedigree data summary after recoding:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Created linkage ped tree
## Done checking locus integrity.
## Checking pedigree integrity...
## Done checking pedigree integrity.
## ==========================================================
## ===========================================================
## Pedigree statistics after selecting chromosomes and marker loci:
## Input pedigree file is in post-makeped format.
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Database file &quot;seqsimr.db&quot; will be backed up.
## Moved existing seqsimr.db to seqsimr.db.old
## Dumping SQLite3 DB to file &quot;seqsimr.db&quot;
## ===========================================================
## See run summaries in directory 2017-7-24-10-03 
##    MEGA2.LOG, MEGA2.RECODE, MEGA2.ERR, MEGA2.KEYS
## The script &#39;mega2log2html.pl&#39; exited normally.
## To view the HTML-formatted run summaries, open
## /Users/rbaron/mega2/bb/srcdir/R/mega2rtutorial/vignettes/2017-7-24-10-03/MEGA2run.html
## in a web browser.
## ===========================================================
</code></pre>

<p>If you do not provide the command-line argument giving the name of the BATCH file, Mega2 will proceed to ask a series
of questions to collect the information needed to produce a
database. In addition, it will create a Mega2.BATCH file, similar to the one we
suggested you use. You can look at the &ldquo;Quick Start&rdquo; section of the Mega2 documentation
<a href="https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html">https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html</a> to
better understand the interactive process.</p>

<p>The MEGA2.BATCH.seqsimr file begins with a rather long comment
indicating the keyword values that may be set and their default
value. Toward the end of the file, we see the inputs set to <strong>Mega2r.ped</strong>
and <strong>Mega2r.map</strong>, indicate the input is PLINK ped format with
parameters, and indicate that Mega2 should produce a database called
<strong>seqsimr.db</strong>, etc. (These particular items are in bold face text
below.)</p>

<blockquote>
<p><strong>Input_Database_Mode=1</strong><br/>
<strong>Input_Format_Type=4</strong><br/>
<strong>Input_Pedigree_File=Mega2r.ped</strong><br/>
<strong>Input_PLINK_Map_File=Mega2r.map</strong><br/>
Output_Path=.<br/>
Input_Path=.<br/>
<strong>PLINK_Args= &ndash;cM &ndash;missing-phenotype -9 &ndash;trait default</strong><br/>
Input_Untyped_Ped_Option=2<br/>
Input_Do_Error_Sim=no<br/>
AlleleFreq_SquaredDev=999999999.000000<br/>
Value_Marker_Compression=1<br/>
<strong>Analysis_Option=Dump</strong><br/>
Value_Missing_Quant_On_Input=-9.000000<br/>
Value_Missing_Affect_On_Input=-9<br/>
Count_Genotypes=4<br/>
Count_Halftyped=no<br/>
Value_Genetic_Distance_Index=0<br/>
Value_Genetic_Distance_SexTypeMap=0<br/>
Value_Base_Pair_Position_Index=1<br/>
Default_Reset_Invalid=no<br/>
<strong>DBfile_name=seqsimr.db</strong><br/>
Default_Outfile_Names=yes  </p>
</blockquote>

<p>If you wish to use any of the Mega2R functions described here on your own data, you will have to run &ldquo;mega2&rdquo; to convert your data into an &#39;SQLite&#39; database.</p>

<h2>5.2 Reading and Examining a Mega2 Database</h2>

<p>The Mega2R package facilitates reading genetic data from a Mega2-created &#39;SQLite&#39; database.</p>

<h3>5.2.1 Reading a Mega2 database</h3>

<p>After you have created the &#39;SQLite&#39; database, start up the R program. Load the Mega2R package, then
use the function <code>read.Mega2DB</code> to read a Mega2 database.</p>

<pre><code class="r">library(Mega2R)
# Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = read.Mega2DB(db, verbose = TRUE)
</code></pre>

<p>The first argument <code>db</code> should be the name of the database (including the path if needed);  here we have set <code>db</code> to point to the <code>seqsimr.db</code> example database file provided with this R package. Providing the
optional argument, <code>verbose</code>, causes the read function to summarize the
tables created, their fields and their sizes. Finally, an &ldquo;R
environment&rdquo;, that contains the database tables is returned. (If you
are unfamiliar with environments, you can think of them as data
frames. <code>ENV$locus_table</code> will access the <code>locus_table</code> variable
from <code>ENV</code> similar to fetching an &ldquo;observation&rdquo; from a data frame. The
difference is when you change a data frame passed to a function, the
change does not affect the original data frame. Only the function&#39;s
local value is changed; ALL changes are forgotten when the function
exits. If you change the data in an environment passed to a function,
the change is permanent.)</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = read.Mega2DB(db, verbose = TRUE)
</code></pre>

<pre><code>## int_table    34  3   
## int_table    pId key value   
## 
## pedigree_table   20  8   
## pedigree_table   pId Num EntryCnt    Name    PedPre  OriginalID  origped pedigree_link   
## 
## person_table 1380    11  
## person_table pId UniqueID    OrigID  FamName PerPre  ID  Father  Mother  Sex pedigree_link   person_link 
## 
## pedigree_brkloop_table   20  8   
## pedigree_brkloop_table   pId Num EntryCnt    Name    PedPre  OriginalID  origped pedigree_link   
## 
## person_brkloop_table 1380    11  
## person_brkloop_table pId UniqueID    OrigID  FamName PerPre  ID  Father  Mother  Sex pedigree_link   person_link 
## 
## locus_table  1001    5   
## locus_table  pId LocusName   Type    AlleleCnt   locus_link  
## 
## allele_table 2002    5   
## allele_table pId AlleleName  Frequency   indexX  locus_link  
## 
## marker_table 1000    7   
## marker_table pId MarkerName  pos_avg pos_female  pos_male    chromosome  locus_link  
## 
## markerscheme_table   1000    4   
## markerscheme_table   pId key allele1 allele2 
## 
## map_table    2000    6   
## map_table    pId marker  map position    pos_female  pos_male    
## 
## mapnames_table   2   6   
## mapnames_table   pId map sex_averaged_map    male_sex_map    female_sex_map  name    
## 
## traitaff_table   1   4   
## traitaff_table   pId ClassCnt    PenCnt  locus_link  
## 
## affectclass_table    1   9   
## affectclass_table    pId MaleDef FemaleDef   AutoDef MalePen FemalePen   AutoPen locus_link  class_link  
## 
## phenotype_table  1380    4   
## phenotype_table  pId person_link bytes   data    
## 
## genotype_table   1380    5   
## genotype_table   pId person_link chr bytes   data    
</code></pre>

<p>For each table generated, if &#39;verbose&#39; is TRUE, we emit two lines: one with
the number of rows and number of columns of the table and the other with
the column names of the table.</p>

<p>We need to make two observations that apply to all Mega2R functions:</p>

<h3>5.2.2 Verbose Flag</h3>

<p>When verbose is set in the initial read.Mega2DB, the
value will be remembered.  It may be used by any subsequent function.
If verbose is TRUE, Mega2R functions can print diagnostic information.</p>

<h3>5.2.3 Use of an Environment</h3>

<p>All Mega2R functions that do not return an
environment need to have an environment supplied as an argument.
As stated earlier, the environment is used to store the data frames that
contain the &#39;SQLite&#39; database.
There are two ways to pass the environment.  If you assigned the result of
<code>read.Mega2DB</code> to the variable <code>seqsimr</code>, then you could supply the value
<code>seqsimr</code> to any Mega2R function as the named argument <code>envir</code>:</p>

<pre><code>showMega2ENV(envir = seqsimr)
</code></pre>

<p>The second choice is a bit of a &ldquo;hack&rdquo; but it is very
convenient. Every Mega2R function (that does not return an
environment) has a named <code>envir</code> argument defined to take on the default value <code>ENV</code>: </p>

<pre><code>envir = ENV
</code></pre>

<p>as in</p>

<pre><code>showMega2ENV = function(envir = ENV) { ... }
</code></pre>

<p>The code above, assigns global variable <code>ENV</code> to the local 
variable, <code>envir</code>.  Thus if <code>envir</code> is not provided in the function call, R
will look up the value of <code>ENV</code> in the global environment.
This &ldquo;hack&rdquo; does not handle the case where <code>ENV</code> is defined in an outer frame which is
not the global environment.
In this situation, we search backwards/upwards from the calling frame to find
the first <code>ENV</code> and use it.</p>

<h3>5.2.4 Back to more examples.</h3>

<p>The <code>ls</code> function will show you all the variables in an
environment. (You probably have used it without arguments to show you the
variables in the .GlobalEnv.) Type:</p>

<pre><code class="r">ls(ENV)
</code></pre>

<pre><code>##  [1] &quot;LocusCnt&quot;               &quot;MARKER_SCHEME&quot;         
##  [3] &quot;Mega2R&quot;                 &quot;PhenoCnt&quot;              
##  [5] &quot;affectclass_table&quot;      &quot;allele_table&quot;          
##  [7] &quot;chr2int&quot;                &quot;entrezGene&quot;            
##  [9] &quot;fam&quot;                    &quot;int_table&quot;             
## [11] &quot;locus_allele_table&quot;     &quot;locus_table&quot;           
## [13] &quot;map_table&quot;              &quot;mapnames_table&quot;        
## [15] &quot;marker_table&quot;           &quot;markers&quot;               
## [17] &quot;markerscheme_table&quot;     &quot;pedigree_brkloop_table&quot;
## [19] &quot;pedigree_table&quot;         &quot;person_brkloop_table&quot;  
## [21] &quot;person_table&quot;           &quot;phenotype_table&quot;       
## [23] &quot;positionVsName&quot;         &quot;refIndices&quot;            
## [25] &quot;refRanges&quot;              &quot;traitaff_table&quot;        
## [27] &quot;txdb&quot;                   &quot;unified_genotype_table&quot;
## [29] &quot;verbose&quot;
</code></pre>

<p>A more informative overview of the database can be had with:</p>

<pre><code class="r">showMega2ENV()
</code></pre>

<pre><code>## locus count:   1001; phenotype count:  1; compression: 2 bits
## marker count:  1000; sample count:  1380
## 
## genetic and physical maps:
##   map name map number
## 1      Map          0
## 2       BP          1
## 
## Phenotypes:
##   Index    Name      Type
## 1     1 default affection
## 
## 
## basic tables:
##                        rows cols
## affectclass_table         1    9
## allele_table           2002    5
## int_table                34    3
## locus_table            1001    5
## map_table              2000    6
## mapnames_table            2    6
## marker_table           1000    8
## markerscheme_table     1000    4
## pedigree_brkloop_table   20    8
## pedigree_table           20    8
## person_brkloop_table   1380   11
## person_table           1380   11
## phenotype_table        1380    4
## traitaff_table            1    4
## 
## derived tables:
##                        rows cols
## fam                    1380    8
## markers                1000    5
## unified_genotype_table 1380    2
</code></pre>

<h3>5.2.5 Use standard R operations to examine the created data frames</h3>

<pre><code class="r">str(ENV$locus_table)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    1001 obs. of  5 variables:
##  $ pId       : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ LocusName : chr  &quot;default&quot; &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; ...
##  $ Type      : int  2 4 4 4 4 4 4 4 4 4 ...
##  $ AlleleCnt : int  2 2 2 2 2 2 2 2 2 2 ...
##  $ locus_link: int  0 1 2 3 4 5 6 7 8 9 ...
</code></pre>

<h2>5.3 Iterating through Gene Transcripts</h2>

<p>There are two ways to compute a function on the genotypes (or markers) in all the transcripts.
These examples are explained more thoroughly in below.</p>

<h3>5.3.1 applyFnToRanges</h3>

<p>Mega2R has an internal default list of the chromosome and base pair
ranges for many gene transcripts.  These transcripts come from
the UCSC Genome Browser reference assembly GRCH37.  The list was
further modified to eliminate multiple records from the same gene with
the exact same transcript start and transcript end.  The list contains
about 29,000 records.  We show a bit of the data
frame below. Each row contains 5 values: a transcript id, the gene id
and three position values: chromosome, start base pair and end base
pair.</p>

<pre><code class="r">dim(ENV$refRanges)
</code></pre>

<pre><code>## [1] 29062     5
</code></pre>

<pre><code class="r">head(ENV$refRanges)
</code></pre>

<pre><code>##          XX    SYMBOL TXCHROM   TXSTART     TXEND
## 1 NM_005286    NPBWR2   chr20  62737182  62738184
## 2 NR_026775 LINC00240    chr6  26924771  26991753
## 3 NM_007188     ABCB8    chr7 150725509 150744869
## 4 NM_206883   SLC26A5    chr7 102993176 103086624
## 5 NM_206880     OR2V2    chr5 180581942 180582890
## 6 NM_206876    PPP1CB    chr2  28974613  29025806
</code></pre>

<p>You may load your own range set instead of the default.
You create a data frame that contains at least a chromosome
&ldquo;observation&rdquo;, a start position &ldquo;observation&rdquo;, an end position &ldquo;observation&rdquo;,
and possibly a name &ldquo;observation&rdquo;.
And you create an integer vector that contains the column numbers of the chromosome
&ldquo;observation&rdquo;, the start position &ldquo;observation&rdquo;, the end position &ldquo;observation&rdquo;, and optionally
a name.  If no name position is provided, a name column indicating the position will be added to
the range.
These two become the arguments to the <code>setRanges</code> function, viz.</p>

<pre><code class="r">ranges = matrix(c(1, 2240000, 2245000, 1, 2245000, 2250000, 1, 3760000, 3761000, 
    1, 3761000, 3762000, 1, 3762000, 3763000, 1, 3763000, 3764000, 1, 3764000, 3765000, 
    1, 3765000, 3763760, 1, 3763760, 3767000, 1, 3767000, 3768000, 1, 3768000, 3769000, 
    1, 3769000, 3770000), ncol = 3, nrow = 12, byrow = TRUE)

setRanges(ranges, 1:3)

dim(ENV$refRanges)
</code></pre>

<pre><code>## [1] 12  4
</code></pre>

<pre><code class="r">head(ENV$refRanges)
</code></pre>

<pre><code>##   X1      X2      X3          ChrStartEnd
## 1  1 2240000 2245000 chr1:2240000-2245000
## 2  1 2245000 2250000 chr1:2245000-2250000
## 3  1 3760000 3761000 chr1:3760000-3761000
## 4  1 3761000 3762000 chr1:3761000-3762000
## 5  1 3762000 3763000 chr1:3762000-3763000
## 6  1 3763000 3764000 chr1:3763000-3764000
</code></pre>

<p>If you provide an index vector of 4 entries, the last one is assumed
to be the column of the name for the range.</p>

<pre><code class="r">ranges = matrix(c(1, 2240000, 2245000, 1, 2245000, 2250000, 1, 3760000, 3761000, 
    1, 3761000, 3762000, 1, 3762000, 3763000, 1, 3763000, 3764000, 1, 3764000, 3765000, 
    1, 3765000, 3763760, 1, 3763760, 3767000, 1, 3767000, 3768000, 1, 3768000, 3769000, 
    1, 3769000, 3770000), ncol = 3, nrow = 12, byrow = TRUE)
ranges = data.frame(ranges)
ranges$name = LETTERS[1:12]
names(ranges) = c(&quot;chr&quot;, &quot;start&quot;, &quot;end&quot;, &quot;name&quot;)

setRanges(ranges, 1:4)
dim(ENV$refRanges)
</code></pre>

<pre><code>## [1] 12  4
</code></pre>

<pre><code class="r">head(ENV$refRanges)
</code></pre>

<pre><code>##   chr   start     end name
## 1   1 2240000 2245000    A
## 2   1 2245000 2250000    B
## 3   1 3760000 3761000    C
## 4   1 3761000 3762000    D
## 5   1 3762000 3763000    E
## 6   1 3763000 3764000    F
</code></pre>

<h3>5.3.2 applyFnToRanges</h3>

<p>The function:</p>

<blockquote>
<p>applyFnToRanges(DOcallback, envir = ENV)  </p>
</blockquote>

<p>goes through each transcript/range entry in the default list of ranges
and finds the markers that fall within the bounds.  It then invokes the callback function
for the range; the callback function is the first argument of the <em>applyFnToRanges</em> function.
For all ranges that contain the same set of markers, the call back function is evaluated only once.
(Note: This situation arises either because multiple named transcripts have the same start and end
positions or because the granularity of the markers sampled is such that small changes in a range
start and end position do not introduce additional markers into the range.)</p>

<p>The callback function is
called with three arguments: the markers in range, the selected transcript/range
entry and the environment.  The callback function is expected to build an
appropriate genotype matrix for the samples and each marker in the range (see Section 5.4).
The call back is invoked repeatedly for each transcript range that contains any markers.
If it is necessary to store information between successive invocations the environment (<code>envir</code>) 
can be used.</p>

<p>For the examples that follow, we use “show” as the call back
function. As you can see, all it does is prints its range argument,
markers argument and the head of the generated genotype matrix, in that
order. It also prints a banner before each argument. Note:
It does not print the environment argument value because
it does not change.</p>

<pre><code class="r">show = function(m, r, e) {
    print(&quot;rrrrrrrrrr&quot;)
    print(r)
    print(&quot;mmmmmmmmmm&quot;)
    print(m)
    print(&quot;g6g6g6g6g6&quot;)
    print(head(getgenotypes(m, envir = e)))
}
</code></pre>

<p>A simple example is shown below with the ranges value that was last
set. We see that the ranges named “A” and “E” have markers in our
example data set.</p>

<pre><code class="r"># apply function &#39;show&#39; to all the ranges ranges
ENV$verbose = FALSE
applyFnToRanges(show)
</code></pre>

<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   chr   start     end name
## 1   1 2240000 2245000    A
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 57         57              57   snp22730          1  2243896
## 58         58              58   snp22731          1  2243897
## 59         59              59   snp22733          1  2243899
## 60         60              60   snp22735          1  2243901
## 61         61              61   snp23360          1  2244526
## 62         62              62   snp23361          1  2244527
## 63         63              63   snp23362          1  2244528
## 64         64              64   snp23364          1  2244530
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;21&quot; &quot;12&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;22&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;21&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;21&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;11&quot; &quot;11&quot;
## [1] &quot;rrrrrrrrrr&quot;
##   chr   start     end name
## 5   1 3762000 3763000    E
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 65         65              65   snp24037          1  3762181
## 66         66              66   snp24039          1  3762183
## 67         67              67   snp24041          1  3762185
## 68         68              68   snp24048          1  3762192
## 69         69              69   snp24494          1  3762638
## 70         70              70   snp24499          1  3762643
## 71         71              71   snp24506          1  3762650
## 72         72              72   snp24507          1  3762651
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [2,] &quot;22&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot;
## [6,] &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
</code></pre>

<p>applyFnToRanges can also be provided explicit ranges as show
below. This run is using a different set of ranges and thus finds a
different set of ranges with markers: viz. range8m and range9m.</p>

<pre><code class="r"># apply function &#39;show&#39; to all genotypes on chromosomes 1 ranges
applyFnToRanges(show, ranges_arg = matrix(c(1, 4e+06, 5e+06, &quot;range4m&quot;, 1, 5e+06, 
    6e+06, &quot;range5m&quot;, 1, 6e+06, 7e+06, &quot;range6m&quot;, 1, 7e+06, 8e+06, &quot;range7m&quot;, 1, 
    8e+06, 9e+06, &quot;range8m&quot;, 1, 9e+06, 1e+07, &quot;range9m&quot;), ncol = 4, nrow = 6, byrow = TRUE), 
    indices_arg = 1:4)
</code></pre>

<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   X1    X2    X3      X4
## 5  1 8e+06 9e+06 range8m
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 73         73              73   snp30480          1  8264348
## 74         74              74   snp30484          1  8264352
## 75         75              75   snp30487          1  8264355
## 76         76              76   snp30491          1  8264359
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [1] &quot;rrrrrrrrrr&quot;
##   X1    X2    X3      X4
## 6  1 9e+06 1e+07 range9m
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 77         77              77   snp32565          1  9124463
## 78         78              78   snp32567          1  9124465
## 79         79              79   snp32568          1  9124466
## 80         80              80   snp32570          1  9124468
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
</code></pre>

<h3>5.3.3 setAnnotations</h3>

<p>If you are iterating/selecting via genes, the default transcript
database is &ldquo;TxDb.Hsapiens.UCSC.hg19.knownGene&rdquo; from Bioconductor; it
is stored in the environment as shown below:</p>

<pre><code class="r">ENV$txdb
</code></pre>

<pre><code>## [1] &quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;
</code></pre>

<pre><code class="r">ENV$entrezGene
</code></pre>

<pre><code>## [1] &quot;org.Hs.eg.db&quot;
</code></pre>

<p>Of course, you can change this database. Suppose we want to use build “hg18”, we would run:</p>

<pre><code>    setAnnotations(&quot;TxDb.Hsapiens.UCSC.hg18.knownGene&quot;, &quot;org.Hs.eg.db&quot;)
</code></pre>

<p>Note: This gene also has transcript uc001akz.2 but its range is included within the uc001aky.1
transcript, so it is not processed.</p>

<p>If you are not using the &ldquo;hg19&rdquo; default,
the <code>setAnnotations</code> command must be issued whenever R is started after the <code>Mega2R</code>
library has been loaded.  By way of a reminder, Section 4.2
explains how to choose and install &ldquo;TxDb.Hsapiens.UCSC.hg19.knownGene&rdquo; or a different
Annotation database.</p>

<h3>5.3.4 applyFnToGenes</h3>

<p>The function applyFnToGenes is called below to look for the
transcripts of genes.  We happen to know gene, “CEP104”, is in our
data. Remember, this lookup is using “hg18”.</p>

<pre><code class="r"># apply function &#39;show&#39; to all transcripts on genes ELL2 and CARD15
applyFnToGenes(show, genes_arg = c(&quot;CEP104&quot;))
</code></pre>

<pre><code>## 
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns
</code></pre>

<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID  ALIAS SYMBOL TXID     TXNAME TXCHROM TXSTRAND TXSTART   TXEND
## 1     9731 CEP104 CEP104 4281 uc001aky.2       1        - 3728645 3773797
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 65         65              65   snp24037          1  3762181
## 66         66              66   snp24039          1  3762183
## 67         67              67   snp24041          1  3762185
## 68         68              68   snp24048          1  3762192
## 69         69              69   snp24494          1  3762638
## 70         70              70   snp24499          1  3762643
## 71         71              71   snp24506          1  3762650
## 72         72              72   snp24507          1  3762651
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [2,] &quot;22&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot;
## [6,] &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
</code></pre>

<p>Switching to “hg19”, we see a different transcript id and transcript
name as well as different start/end. But the same set of markers from
our study fall in each range.</p>

<pre><code class="r">setAnnotations(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;, &quot;org.Hs.eg.db&quot;)
applyFnToGenes(show, genes_arg = c(&quot;CEP104&quot;))
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns
</code></pre>

<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID  ALIAS SYMBOL TXID     TXNAME TXCHROM TXSTRAND TXSTART   TXEND
## 1     9731 CEP104 CEP104 4281 uc001aky.2       1        - 3728645 3773797
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 65         65              65   snp24037          1  3762181
## 66         66              66   snp24039          1  3762183
## 67         67              67   snp24041          1  3762185
## 68         68              68   snp24048          1  3762192
## 69         69              69   snp24494          1  3762638
## 70         70              70   snp24499          1  3762643
## 71         71              71   snp24506          1  3762650
## 72         72              72   snp24507          1  3762651
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [2,] &quot;22&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot;
## [6,] &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
</code></pre>

<p>The applyFnToGenes function has several other optional arguments that
can request complete chromosomes, (multiple) ranges of base pairs on
chromosomes, or collections of markers, in addition to the genes_arg
argument. All these arguments define ranges that are passed to
applyFnToRanges for evaluation. Note: If the genes_arg argument is set
to the special &ldquo;gene&rdquo; string &ldquo;*&rdquo;, then all transcripts in the
Bioconductor database, will match and be processed.</p>

<pre><code class="r"># apply function &#39;show&#39; to all genotypes on chromosomes 1 for two base pair
# ranges
applyFnToGenes(show, ranges_arg = matrix(c(1, 5e+06, 1e+07, 1, 1e+07, 1.5e+07), ncol = 3, 
    nrow = 2, byrow = TRUE))
</code></pre>

<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID ALIAS           SYMBOL TXID TXNAME TXCHROM TXSTRAND TXSTART
## 1        -     - chr1:5e+06-1e+07    0      -       1        -   5e+06
##   TXEND
## 1 1e+07
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 73         73              73   snp30480          1  8264348
## 74         74              74   snp30484          1  8264352
## 75         75              75   snp30487          1  8264355
## 76         76              76   snp30491          1  8264359
## 77         77              77   snp32565          1  9124463
## 78         78              78   snp32567          1  9124465
## 79         79              79   snp32568          1  9124466
## 80         80              80   snp32570          1  9124468
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID ALIAS             SYMBOL TXID TXNAME TXCHROM TXSTRAND TXSTART
## 2        -     - chr1:1e+07-1.5e+07    0      -       1        -   1e+07
##     TXEND
## 2 1.5e+07
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 81         81              81   snp34070          1 12812974
## 82         82              82   snp34071          1 12812975
## 83         83              83   snp34074          1 12812978
## 84         84              84   snp34075          1 12812979
## 85         85              85   snp34533          1 12813437
## 86         86              86   snp34534          1 12813438
## 87         87              87   snp34535          1 12813439
## 88         88              88   snp34536          1 12813440
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;22&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;21&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;21&quot; &quot;11&quot;
## [5,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;21&quot; &quot;21&quot; &quot;11&quot;
</code></pre>

<pre><code class="r"># apply function &#39;show&#39; to all genotypes for first marker in each chromosome (We
# only have data for chromosome 1.)  NOTE: Since we are using an arbitrary
# collection of markers, the range is not available.
applyFnToGenes(show, markers_arg = ENV$markers[!duplicated(ENV$markers$chromosome), 
    3])
</code></pre>

<pre><code>## [1] &quot;rrrrrrrrrr&quot;
## NULL
## [1] &quot;mmmmmmmmmm&quot;
##   locus_link locus_link_fill MarkerName chromosome position
## 1          1               1       snp1          1        2
## [1] &quot;g6g6g6g6g6&quot;
##      [,1]
## [1,] &quot;11&quot;
## [2,] &quot;11&quot;
## [3,] &quot;12&quot;
## [4,] &quot;11&quot;
## [5,] &quot;11&quot;
## [6,] &quot;11&quot;
</code></pre>

<pre><code class="r"># apply function &#39;show&#39; to all genotypes on chromosomes 24 and 26.  remember our
# example database is only chr 1
applyFnToGenes(show, chrs_arg = c(24, 26))
</code></pre>

<h2>5.4 Iterating through the Genotypes</h2>

<p>The callback functions described above will need the genotype information for the 
selected markers.  The two functions below will collect that data.  The first, <code>getgenotypes</code>,
will return the allele nucleodides as they were coded in the sample data.
(This function was illustrated
by the <code>show</code> function above.)  The second, <code>getgenotypesraw</code>, will return the
allele numbers 1 and 2 encoded into an integer.  The corresponding nucleotide can be looked
up if needed.</p>

<h3>5.4.1 Encoded Genotypes</h3>

<p>The heart of the callback functions is the calculation of the genotype 
matrix of samples by markers.  The
genotype information is most often stored in a compressed 2 bit representation.
An Rcpp function does the
conversion of the compressed genotype data to nucleotides.  The function</p>

<blockquote>
<p>getgenotypes(markers, envir = ENV)</p>
</blockquote>

<p>returns the matrix for the specified markers.  It can take one additional argument that
supplies a string to separate the two alleles of each marker.
We will build a matrix for the first 10 markers of our data. Remember
our database has 1380 samples so we will just show the head of the
matrix.</p>

<pre><code class="r">genotype = getgenotypes(ENV$markers[1:10, ])
dim(genotype)
</code></pre>

<pre><code>## [1] 1380   10
</code></pre>

<pre><code class="r">head(genotype)
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;12&quot; 
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [3,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [5,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;21&quot; &quot;12&quot;
</code></pre>

<h3>5.4.2 Raw Genotypes</h3>

<p>The function</p>

<blockquote>
<p>getgenotypesraw(markers, envir = ENV)</p>
</blockquote>

<p>is similar to the <code>getgenotypes</code> function except that the matrix it returns
contains an integer encoding for each genotype.  The integer&#39;s
high 16 bits are the index for allele1 and the low 16 bits are the index for allele2.
The function <code>getgenotypesraw</code> will be called with the same 10 markers
as above. </p>

<pre><code class="r"># two ints in upper/lower half integer representing allele
raw = getgenotypesraw(ENV$markers[1:10, ])
dim(raw)
</code></pre>

<pre><code>## [1] 1380   10
</code></pre>

<pre><code class="r">head(raw)
</code></pre>

<pre><code>##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]   [,9] [,10]
## [1,] 65537 65537 65537 65537 65537 65537 65537 65537 131073 65538
## [2,] 65537 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [3,] 65538 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [4,] 65537 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [5,] 65537 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [6,] 65537 65537 65537 65537 65537 65537 65537 65537 131073 65538
</code></pre>

<p>Note: There are actually two different Rcpp functions for each named function in Section 5.4.  One function processes compressed genotype data and the other function processes 
uncompressed genotype data.</p>

<h1>6 Using Mega2R to carry out automated gene-based association tests using &#39;pedgene&#39;</h1>

<p>Mega2R provides functions that permit one to run the &#39;pedgene&#39; package to carry
out gene-based association tests on family data looping over selected
marker subsets.  </p>

<p>The &#39;pedgene&#39; package implements methods for carrying out gene-based association tests on family data, and is available on CRAN as (<a href="https://CRAN.R-project.org/package=pedgene">https://CRAN.R-project.org/package=pedgene</a>).
It was written by Daniel Schaid and Jason Sinnwell: 
[Schaid DJ, McDonnell SK., Sinnwell JP, Thibodeau SN. (2013) Multiple Genetic Variant Association Testing by Collapsing and Kernel Methods With Pedigree or Population Structured Data, Genet Epidemiol, 37(5):409-18.]</p>

<h2>6.1 Loading a Mega2 database</h2>

<p>Rather than read the Mega2 &#39;SQLite&#39; database with
the <code>read.Mega2DB</code> function described previously, here we use a specialized <code>init_pedgene</code> function to read the Mega2 database.
This latter function calls a utility function
also used by  <code>read.Mega2DB</code>. Then it creates, edits, and rewrites the family data, storing it in a <code>pedgene</code>-compatible data frame, <code>fam</code> .  (<code>fam</code> merges data from the <code>pedigree_table</code>, <code>person_table</code> and
<code>phenotype_table</code>.)
<code>init_pedgene</code> purges persons with unknown case/control
status which is necessary for the pedgene calculation.
(When <code>fam</code> is filtered, similar filtering is done to the phenotype_table and the
genotype_table.)
Finally, <code>init_pedgene</code> calculates
some values that will be used repeatedly and stores them in the environment that is returned.</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = init_pedgene(db)
</code></pre>

<h2>6.2 Gene Ranges reminder</h2>

<p>Mega2R has an internal default list of the chromosome and base pair
ranges for a number of gene transcripts.  These transcripts come from
the UCSC Genome Browser reference assembly GRCH37.  The list was
further modified to eliminate multiple records of the same gene with
the exact same transcript start and transcript end.  These data contain
about 29,000 records.   You may load your own range set instead of the default.
You create a data frame that contains at least a name &ldquo;observation&rdquo;, a chromosome
&ldquo;observation&rdquo;, a start position &ldquo;observation&rdquo; and an end position &ldquo;observation&rdquo;.
Then, you create an integer vector that contains the column numbers of the chromosome
&ldquo;observation&rdquo;, the start position &ldquo;observation&rdquo; and the end position &ldquo;observation&rdquo;.
These two objects are then arguments to the <code>setRanges</code> function, viz.</p>

<pre><code>        setRanges(Transcripts, Columns)
</code></pre>

<h2>6.3 Gene transcripts reminder</h2>

<p>If you plan to select transcripts by gene name, you must load them from
Bioconductor.  In Section 4.2, we indicated that you 
needed to type once to install the package:</p>

<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)
biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)
</code></pre>

<p>And then, to use the desired transcription data base, use this command from the Mega2R package as part of your session:</p>

<pre><code>setAnnotations(txdb, entrezGene)
</code></pre>

<p>where <code>txdb</code> is the name of Bioconductor transcription database, and <code>entrezGene</code> is the name of Bioconductor mapping of gene name or gene alias to entrez gene id.</p>

<h3>6.4 Running pedgene on transcripts</h3>

<p>By default, the function <code>Mega2pedgene</code> examines the first 100
default transcripts and prints the results. For this database, the first 100 transcripts
identifies only one transcript with several markers (It is found
because it is on chromosome 1 and it has a range that overlaps with some of the
markers in our study.)
To make this tutorial exercise run 
faster, we noticed that the identified transcript appeared at transcript 54; so we will
restrict pedgene to a small range of transcripts around 54, viz. 50 through
60: </p>

<p>Note: <code>verbose</code> needs to be TRUE, for these diagnostics to be printed.</p>

<pre><code class="r">ENV$verbose = TRUE
Mega2pedgene(gs = 50:60)
</code></pre>

<pre><code>## tryFn() No markers in range: NR_052010, IL11RA, 9, 34653893, 34661898
</code></pre>

<pre><code>## tryFn() No markers in range: NR_045785, CHIT1, 1, 203185206, 203198860
</code></pre>

<pre><code>## tryFn() No markers in range: NM_017799, TMEM260, 14, 57046510, 57116232
</code></pre>

<pre><code>## tryFn() No markers in range: NM_014705, DOCK4, 7, 111366163, 111846462
</code></pre>

<pre><code>## tryFn() No markers in range: NM_003759, SLC4A4, 4, 72204769, 72437804
</code></pre>

<pre><code>## tryFn() No markers in range: NM_002192, INHBA, 7, 41728600, 41742706
</code></pre>

<pre><code>## tryFn() No markers in range: NM_002202, ISL1, 5, 50678957, 50690563
</code></pre>

<pre><code>## tryFn() No markers in range: NM_003659, AGPS, 2, 178257470, 178408564
</code></pre>

<pre><code>## tryFn() No markers in range: NM_003658, BARX2, 11, 129245880, 129322174
</code></pre>

<pre><code>## tryFn() No markers in range: NM_018051, WDR60, 7, 158649268, 158738883
</code></pre>

<pre><code>## CEP104 snp24037 520 646 214 
## CEP104 snp24039 940 386 54 
## CEP104 snp24041 1377 3 0 
## CEP104 snp24048 860 460 60 
## CEP104 snp24494 789 501 90 
## CEP104 snp24499 891 442 47 
## CEP104 snp24506 891 442 47 
## CEP104 snp24507 789 501 90 
##   chr   gene nvariants   start     end sKernel_BT pKernel_BT sBurden_BT
## 1   1 CEP104         8 3728644 3773797   31.96998  0.6297541 -0.6496837
##   pBurden_BT sKernel_MB pKernel_MB sBurden_MB pBurden_MB sKernel_UW
## 1  0.5158965   1184.995  0.5138866  -1.209563  0.2264468   222.8737
##   pKernel_UW sBurden_UW pBurden_UW
## 1  0.4111136  -1.169488   0.242207
</code></pre>

<p>You will see many reports
of &ldquo;No markers in range&rdquo;, because the database only contains markers on a subrange of 
chromosome 1 whereas the transcripts span
the entire genome.
Occasionally you will see a listing of a
gene name, markers, and count of 0, 1 and 2 genotypes, viz.</p>

<pre><code>CEP104 snp24037 520 646 214  
CEP104 snp24039 940 386 54  
CEP104 snp24041 1377 3 0  
CEP104 snp24048 860 460 60  
CEP104 snp24494 789 501 90  
CEP104 snp24499 891 442 47  
CEP104 snp24506 891 442 47  
CEP104 snp24507 789 501 90
</code></pre>

<p>The genotype matrix for these markers, along with the markers, the range
used, and the environment are passed
to the call back function <code>DOpedgene</code>. <code>DOpedgene</code> converts the raw genotype
encodings,  0x10001, 0x10002 (or 0x20001), and 0x20002 to the values 0, 1 and 2 (or 2, 1, 0)
if 0x10001 is the
genotype for the allele with the minor allele frequency.  Then it runs <code>pedgene</code>. 
The results are automatically stored
in a data frame with &ldquo;observations&rdquo;: prefix of chromosome, gene,
number of markers and base pair range followed by Pedgene data: kernel
and burden, value and p-values, four values for each of three
weightings of the markers.
These data are saved in the data frame, <code>pedgene_results</code>, in the environment.
They are also printed when <code>verbose</code> is TRUE, viz.</p>

<p>Note: The results are always appended to the data frame.  You should truncate it
when necessary.</p>

<pre><code>   chr   gene nvariants   start     end sKernel_BT pKernel_BT sBurden_BT  
1 chr1 CEP104         8 3728644 3773797   31.96998  0.6297541 -0.6496837  
  pBurden_BT sKernel_MB pKernel_MB sBurden_MB pBurden_MB sKernel_UW pKernel_UW  
1  0.5158965   1184.995  0.5138866  -1.209563  0.2264468   222.8737  0.4111136  
  sBurden_UW pBurden_UW  
1  -1.169488   0.242207
</code></pre>

<p>You could run <code>Mega2pedgene</code> on all the transcript entries, but it takes a rather long time.
You would type:</p>

<pre><code class="r"># we will skip this line for the Rmd document production because it takes too
# long
applyFnToRanges(DOpedgene, ENV$refRanges, ENV$refIndices, envir = ENV)
</code></pre>

<p>If you run the above test, you will see that genes DISP1 and KIF26B
have at least one p-value less than 0.01 and AK5 and STL7 at least one less than 0.03.</p>

<h3>6.5 Running pedgene on selected genes</h3>

<p>You may try searching for transcripts of specific genes.  Here, the default
transcript database is <code>TxDb.Hsapiens.UCSC.hg19.knownGene</code> from
Bioconductor.  Of course you can change it.  Type:</p>

<pre><code>setAnnotations(&quot;txdb&quot;, &quot;genedb&quot;)
</code></pre>

<p>where &ldquo;txdb&rdquo; is a string that is the name of transcript database that was
fetched from Bioconductor, and similarly &ldquo;genedb&rdquo; is the name of a Bioconductor
database that maps a gene id from the input to an entrez gene id.
You need to install any new database with biocLite, as shown earlier.</p>

<p>We leave the command below as an exercise.  It runs a bit slowly.  It needs to find
all  the transcripts for each gene, to find all the markers between each pair
of transcript start/end ranges, to compute the genotype matrix for these markers,
and finally to call the callback function with appropriate arguments.</p>

<pre><code class="r">applyFnToGenes(DOpedgene, genes_arg = c(&quot;DISP1&quot;, &quot;KIF26B&quot;, &quot;AK5&quot;, &quot;ST7L&quot;), envir = ENV)
</code></pre>

<p>But let us run this function for a few genes:</p>

<pre><code class="r">applyFnToGenes(DOpedgene, genes_arg = c(&quot;DISP1&quot;, &quot;AK5&quot;), envir = ENV)
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns
</code></pre>

<pre><code>## tryFn() No markers in range: 26289, AK5, AK5, 1624, uc001dhm.2, 1, +, 77747662, 77780745
</code></pre>

<pre><code>## AK5 snp80127 962 375 43 
## AK5 snp80131 1095 272 13 
## AK5 snp80142 1303 77 0 
## AK5 snp80148 1345 35 0 
##   chr gene nvariants    start      end sKernel_BT pKernel_BT sBurden_BT
## 2   1  AK5         4 77747662 78025654   2593.945   0.228311  -1.400928
##   pBurden_BT sKernel_MB pKernel_MB sBurden_MB pBurden_MB sKernel_UW
## 2  0.1612355   1899.249 0.06206979  -2.263002 0.02363554   175.4195
##   pKernel_UW sBurden_UW pBurden_UW
## 2   0.051013  -2.290307  0.0220035
## DISP1 snp332780 1375 5 0 
## DISP1 snp332781 675 559 146 
## DISP1 snp332783 1365 15 0 
## DISP1 snp332784 898 427 55 
##   chr  gene nvariants     start       end sKernel_BT  pKernel_BT
## 3   1 DISP1         4 222988431 223179337    4559.34 0.004224181
##   sBurden_BT pBurden_BT sKernel_MB  pKernel_MB sBurden_MB  pBurden_MB
## 3    1.44652  0.1480315   5410.868 0.000253584   2.916462 0.003540261
##   sKernel_UW pKernel_UW sBurden_UW pBurden_UW
## 3    277.508 0.04407319   2.094983 0.03617254
</code></pre>

<p>You could run <code>Mega2pedgene</code> on all the transcript entries, but it takes a rather long time.
You would type:</p>

<pre><code class="r"># we will skip this line for the Rmd document production because it takes too
# long
applyFnToGenes(DOpedgene, genes_arg = &quot;*&quot;, envir = ENV)
</code></pre>

<p>Note: The default behavior of <code>DOpedgene</code> is to append any new results to the end of the
<code>ENV$pedgene_results</code> data frame.</p>

<h1>7 Using Mega2R to carry out automated gene-based association tests using &#39;SKAT&#39;</h1>

<p>Mega2R provides functions to run the &#39;SKAT&#39; package to carry
out gene-based association tests using a kernel regression framework while
looping over selected marker subsets.</p>

<p>The &#39;SKAT&#39; package implements methods for carrying out gene-based association tests; 
it is available on CRAN as (<a href="https://CRAN.R-project.org/package=SKAT">https://CRAN.R-project.org/package=SKAT</a>).
It was written by Seunggeun Lee and Michael Wu: 
[Lee, S., Emond, M.J., Bamshad, M.J., Barnes, K.C., Rieder, M.J., Nickerson, D.A., NHLBI GO
Exome Sequencing Project-ESP Lung Project Team, Christiani, D.C., Wurfel, M.M. and Lin, X.
(2012) Optimal unified approach for rare variant association testing with application to small sample
case-control whole-exome sequencing studies. American Journal of Human Genetics, 91, 224-237.]</p>

<h2>7.1 Loading a Mega2 database</h2>

<p>The <code>init_SKAT</code> function is used to read the Mega2 database and initialize processing.
This function calls the utility function, <code>dbmega2_import</code>, to read the database.
Then it creates, edits, and rewrites the family data, storing it in the data frame, <code>fam</code>. 
(<code>fam</code> contains data merged from the <code>pedigree_table</code>, <code>person_table</code> and
<code>phenotype_table</code>.)
<code>init_SKAT</code> purges persons from the <code>fam</code> data frame with unknown case/control
status. <code>setfam</code> sets <code>fam</code> in the environment and insures that
filtering is done to the phenotype_table and the genotype_table
so they all have the same person_link key.
Next, <code>init_SKAT</code> decodes the phenotype_table into a simple data frame, <code>phe</code>.
You will definitely want to examine <code>ENV</code>$<code>phe</code> to choose which phenotype to use
for the case/control.
In addition, <code>init_SKAT</code> calculates
some values that will be used repeatedly and stores them in the environment that is returned.
Finally, <code>init_SKAT</code> stores the argument <code>allMarkers</code> which tells later processing to ignore
markers that show no variation (if FALSE).</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = init_SKAT(db, verbose = F, allMarkers = F)
</code></pre>

<p>You can run the command with verbose equals TRUE to see details of the database as it is loaded:</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = init_SKAT(db, verbose = T, allMarkers = F)
</code></pre>

<h2>7.2 Gene Ranges reminder</h2>

<p>Mega2R also has an internal default list of the chromosome and base pair
ranges for many gene transcripts.  These transcripts come from
the UCSC Genome Browser reference assembly GRCH37.  The list was
further modified to eliminate multiple records from the same gene with
the exact same transcript start and transcript end.  The list contains
about 29,000 records.  You may load your own range set instead of the default.
Create a data frame that contains at least a name &ldquo;observation&rdquo;, a chromosome
&ldquo;observation&rdquo;, a start position &ldquo;observation&rdquo; and an end position &ldquo;observation&rdquo;.
And create an integer vector that contains the column numbers of the chromosome
&ldquo;observation&rdquo;, the start position &ldquo;observation&rdquo; and the end position &ldquo;observation&rdquo;.
These two become the arguments to the <code>setRanges</code> function, viz.</p>

<pre><code>setRanges(Ranges, Columns)
</code></pre>

<h2>7.3 Gene transcripts reminder</h2>

<p>Gene transcripts are defined according to a Bioconductor database containing the boundaries of the gene transcripts
or defined by an internal table, <code>refRanges</code>, with the boundaries.
The gene transcripts require two Bioconductor Annotations databases to be installed.
The first line (below) loads the Bioconductor loader and the next
two lines install two annotation databases. One annotation database provides the gene transcript
locations and the other maps gene names to entrez gene IDs. (Note: You
may choose a different transcript database from Bioconductor or
construct one of your own.) Please type in R:</p>

<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)

biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)
</code></pre>

<p>The above step is run once.</p>

<p>By default, Mega2R presumes that the databases, &ldquo;TxDb.Hsapiens.UCSC.hg19.knownGene&rdquo; and &ldquo;org.Hs.eg.db&rdquo; are 
selected.  Otherwise you must make your choices known to Mega2 via the command:</p>

<pre><code>setAnnotations(txdb, entrezGene)
</code></pre>

<p>where <code>txdb</code> is the name of Bioconductor transcription database, and <code>entrezGene</code> is the name of Bioconductor mapping of gene name or gene alias to entrez gene id.</p>

<p>Note that, in this case, if <code>init_SKAT</code> has been run as indicated above, then it loaded both a <code>txdb</code> and a <code>entrezGene</code> into the <code>ENV</code> environment.  While these are already the set annotations, we could explicitly set them via this command:</p>

<pre><code>setAnnotations(ENV$txdb, ENV$entrezGene)
</code></pre>

<h2>7.4 Running Mega2SKAT on ranges</h2>

<p>You should be familiar with the SKAT functions of the SKAT package before you read this section.
The function, <code>Mega2SKAT</code>, is Mega2R&#39;s interface to SKAT, both to <code>SKAT_Null_Model</code> and
<code>SKAT</code>.  Its signature is:</p>

<pre><code>Mega2SKAT = function (f, ty, gs = 1:100, skat = SKAT::SKAT, envir = ENV, ...) { }
</code></pre>

<p>The <code>gs</code> argument indicates how many default range elements should be processed and the <code>envir</code>
argument specifies the environment that contains all the Mega2R data frames.</p>

<p>Most of the time, before you call <code>SKAT</code>, you need to call <code>SKAT_Null_Model</code> with a formula
and an indicator for the type of the phenotype.  <code>Mega2SKAT</code> will take its first two arguments,
a formula and a type (string) and call <code>SKAT_Null_Model</code> with this information, viz.</p>

<pre><code>SKAT_Null_Model(f, out_type = ty)
</code></pre>

<p>and store the results (in obj in the environment).</p>

<p>If the formula, <code>f</code>, is NULL, Mega2SKAT will not call <code>SKAT_Null_Model</code> and you must do the 
equivalent before calling <code>Mega2SKAT</code>.  Store the result object in ENV$obj.
There are several reasons a custom call to the build
the model could be necessary.  You might want to use <code>SKAT_Null_Model</code> but provided additional 
arguments viz. data, Adjustment, n.Resampling, type.Resampling.  Alternatively, you might
need to use a different model viz. SKAT_NULL_emmaX, SKAT_Null_Model_ChrX.</p>

<p>The <code>skat</code> argument specifies the name of the SKAT package function to use; this is 
usually SKAT::SKAT, but could be SKAT::SKATBinary, SKAT::SKAT_CommonRare, etc.
Any additional, arguments needed for the &ldquo;skat&rdquo; functions are provided to the <code>Mega2SKAT</code>
function and will be passed to the eventual call.  All the &ldquo;skat&rdquo; functions are called with
a genotype matrix for the markers, the object representing the Null Model and the additional arguments.</p>

<p>The Mega2R loop engine, iterates through each range and determines the
set of markers contained.  If there are no markers in a range, the
genotype matrix is empty and Mega2SKAT will issue a warning.  If a
marker has no variation, Mega2SKAT will omit it, if the variable
allMarkers is FALSE.  Mega2SKAT will include it, if allMarkers is
TRUE, but SKAT will more than likely issue a warning.  The Mega2SKAT
function also defines a callback function that converts the raw genotype
information 0x10001, 0x10002 (or 0x20001) and 0x20002 to 0, 1, and 2 with the
major allele (flipped if necessary to be) 0 and then calls the
specified &ldquo;skat&rdquo; function with the required arguments.  Finally, the
callback function stores the results.</p>

<p>By default, the function <code>Mega2SKAT</code> examines the first 100 transcripts and prints the results.
Note: <code>verbose</code> is FALSE to eliminate the (excessive) diagnostics.
A typical invocation of <code>Mega2SKAT</code> could be:</p>

<pre><code class="r">ENV$verbose = FALSE
ENV$SKAT_results = ENV$SKAT_results[0, ]
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, &quot;D&quot;, kernel = &quot;linear.weighted&quot;, weights.beta = c(0.5, 
    0.5))
</code></pre>

<pre><code>## Sample size (non-missing y and X) = 1380, which is &lt; 2000. The small sample adjustment is applied!
</code></pre>

<p>These data are saved in the data frame, <code>SKAT_results</code>, in the environment.
Note: The results are always appended to the data frame.  You should truncate it
when necessary.</p>

<pre><code class="r">print(ENV$SKAT_results)
</code></pre>

<pre><code>##   chr   gene nvariants   start     end      skat
## 1   1 CEP104         8 3728644 3773797 0.4870178
</code></pre>

<pre><code class="r"># we will skip this line for the Vignette document production because it takes
# too long
ENV$verbose = FALSE
ENV$SKAT_results = ENV$SKAT_results[0, ]
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, &quot;D&quot;, kernel = &quot;linear.weighted&quot;, weights.beta = c(0.5, 
    0.5), gs = 1:nrow(ENV$refRanges))
print(ENV$SKAT_results)
</code></pre>

<h2>7.5 Running Mega2SKAT on genes</h2>

<p>Let us run the Mega2SKAT function for a few genes:</p>

<pre><code class="r">ENV$SKAT_results = ENV$SKAT_results[0, ]
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, &quot;D&quot;, kernel = &quot;linear.weighted&quot;, weights.beta = c(0.5, 
    0.5), genes = c(&quot;DISP1&quot;, &quot;AK5&quot;, &quot;KIF26B&quot;, &quot;ST7L&quot;), envir = ENV)
</code></pre>

<pre><code>## Sample size (non-missing y and X) = 1380, which is &lt; 2000. The small sample adjustment is applied!
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns
</code></pre>

<pre><code class="r">print(ENV$SKAT_results)
</code></pre>

<pre><code>##   chr   gene nvariants     start       end        skat
## 1   1    AK5         4  77747662  78025654 0.061922313
## 2   1   ST7L         2 113066141 113153625 0.027614095
## 3   1 KIF26B         8 245318287 245809683 0.006863812
## 4   1  DISP1         4 222988431 223179337 0.001892741
</code></pre>

<p>Note: we set verbose to FALSE otherwise there will be a large number of print outs indicating no markers are in the range.  (Recall the samples come
from part of chromosome one, whereas the ranges cover the whole genome.)
If you are adventurous you can look at all the transcripts:</p>

<pre><code class="r">ENV$verbose = FALSE
ENV$SKAT_results = ENV$SKAT_results[0, ]
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, &quot;D&quot;, kernel = &quot;linear.weighted&quot;, weights.beta = c(0.5, 
    0.5), genes = &quot;*&quot;, envir = ENV)
</code></pre>

<pre><code>## Sample size (non-missing y and X) = 1380, which is &lt; 2000. The small sample adjustment is applied!
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns
</code></pre>

<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns
</code></pre>

<p>Note: The default behavior of <code>Mega2SKAT</code> is to append any new results to the end of the
<code>ENV$SKAT_results</code> data frame.</p>

<pre><code class="r">print(ENV$SKAT_results)
</code></pre>

<pre><code>##    chr      gene nvariants     start       end         skat
## 1    1   DDX11L1         8     11874     14409 0.0848706596
## 2    1    NBPF20         4 144151519 144830407 0.1568647179
## 3    1 GNG12-AS1         4  68297971  68668670 1.0000000000
## 4    1  MIR548F1         4 186029867 186446655 0.7438388831
## 5    1     TESK2         4  45809555  45956840 0.4749181180
## 6    1   SDCCAG8         8 243419307 243663393 0.7505457597
## 7    1     WDR63         8  85527993  85598821 0.9702720591
## 8    1       CR1        12 207669473 207743990 1.0000000000
## 9    1     GLIS1         4  53971906  54199877 0.4854100754
## 10   1      DAB1         4  57463579  59012446 0.4589188601
## 11   1       DPT         4 168664695 168698442 0.1606558659
## 12   1       AK4         4  65613850  65697828 0.2408631430
## 13   1      EPRS         8 220141942 220220000 1.0000000000
## 14   1     NTNG1         4 107682629 108024475 0.2774302847
## 15   1      ATF6        20 161736034 161835745 0.9233424958
## 16   1    SRGAP2         8 206557369 206628046 0.0914191519
## 17   1       AK5         4  77748287  78025654 0.0620431534
## 18   1    BRINP3         4 190066797 190446759 0.8296514453
## 19   1 LINC01140         4  87458690  87634886 1.0000000000
## 20   1     KCNT2         4 196194913 196577499 0.4932358203
## 21   1   TRABD2B         8  48226200  48462562 0.1955619582
## 22   1   C1orf53         8 197871682 197876497 1.0000000000
## 23   1      NCF2         4 183524697 183559739 0.3937498724
## 24   1      NPR1         4 153652630 153666468 0.9386499124
## 25   1   PLEKHO1         4 150122170 150131825 0.6498569912
## 26   1     PI4KB         8 151264273 151300191 0.4005708789
## 27   1     GDAP2         4 118419844 118472302 0.2983078671
## 28   1      ST7L         2 113084413 113160839 0.0252883598
## 29   1     MARC2        16 220921676 220957596 0.3585786358
## 30   1    KIF26B         8 245318287 245866428 0.0090829538
## 31   1      HHAT         4 210502250 210849638 0.2527692942
## 32   1   GATAD2B         8 153777203 153895451 0.8725338535
## 33   1     LRRC7         4  70032868  70340687 1.0000000000
## 34   1     LRRC7         4  70225874  70589171 0.5370060995
## 35   1      RGS7         4 240938817 241520478 0.5264654537
## 36   1      RYR2         8 237205702 237997288 0.4983249365
## 37   1    SLC2A5         4   9097005   9129887 1.0000000000
## 38   1    WASH7P        12     14362     16765 0.7071786846
## 39   1    WASH7P         8     15603     29370 1.0000000000
## 40   1      EVI5         4  92974253  93257961 0.3267216561
## 41   1     TTC13         4 231041987 231114618 0.7258877876
## 42   1   C1orf21         4 184356150 184598155 0.2674100027
## 43   1    IGSF21         4  18434240  18704977 0.5500376065
## 44   1     DISP1         4 222988431 223179337 0.0009228141
## 45   1       CD2         4 117297086 117311851 0.1034987334
## 46   1  C1orf158         8  12806163  12821102 0.5049194971
## 47   1    NOS1AP         4 162039581 162326974 0.3150683274
## 48   1    CEP104         8   3728653   3773797 0.4920454923
## 49   1    CDK11B         4   1571100   1647917 0.7932239816
</code></pre>

<h1>8 Outputting Mega2R data to VCF format</h1>

<p>The <code>Mega2VCF</code> function can output subsets of the Mega2R database as a VCF file, accompanied by
related files (for phenotype and family data).</p>

<p>The VCF data format 
(<a href="http://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/">http://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/</a>)
was originally defined by the 1000 Genomes Project 
(<a href="http://www.internationalgenome.org/home">http://www.internationalgenome.org/home</a>) for data storage.</p>

<p>The current version of data format can be found at (<a href="http://samtools.github.io/hts-specs/">http://samtools.github.io/hts-specs/</a>).</p>

<h2>8.1 Writing a VCF File using Mega2R</h2>

<p>First, create the directory &ldquo;vcfr&rdquo;,
so we can keep all the generated data in one place.</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
vcfdir = file.path(where_mega2rtutorial_data(), &quot;vcfr&quot;)
if (!dir.exists(vcfdir)) dir.create(vcfdir)
</code></pre>

<p>The Mega2VCF function takes an argument which is the prefix used on
all generated files. We will make it a path that includes the
directory vcfr. Below, we assume that a Mega2 database was stored in
the environment, <code>ENV</code>. If this is not the case, supply to Mega2VCF a
named argument, <code>envir</code>, set to the environment you wish to use. (You
will also have to change the references to the <code>markers</code> data frame,
below, from <code>ENV</code>$markers to
&ldquo;environment name&rdquo;$markers.)</p>

<p>Note that Mega2VCF will create the .vcf file as well as a
.fam file (in linkage format), a .phe file (phenotypes) and a few
others. These files are listed below.</p>

<p>Creating the VCF file and related files is accomplished by typing:</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
vcffile = file.path(where_mega2rtutorial_data(), &quot;vcfr&quot;, &quot;vcf.01&quot;)
Mega2VCF(vcffile, ENV$markers[ENV$markers$chromosome == 1, ])
</code></pre>

<p>Note: The line above places the data for only chromosome 1 in the files 
(Recall that our simulated data is only on chromosome 1).</p>

<p>Note: In general, you can filter <code>ENV$markers</code> as needed.
If the second argument is not present, all the markers are written out.</p>

<p>The generated files are listed below:</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
vcfdir = file.path(where_mega2rtutorial_data(), &quot;vcfr&quot;)
list.files(vcfdir)
</code></pre>

<pre><code>## [1] &quot;vcf.01.fam&quot;  &quot;vcf.01.freq&quot; &quot;vcf.01.map&quot;  &quot;vcf.01.pen&quot;  &quot;vcf.01.phe&quot; 
## [6] &quot;vcf.01.vcf&quot;
</code></pre>

<p>You can read the code to see how these files are created from the data frames.
It is worth noting that the internal logic does not create a genotype matrix for all the requested markers at once, but rather works on a block of markers at a time, limiting the amount of memory required. The code also illustrates how to extract the phenotype values from the phenotype raw vectors.</p>

<h1>9 Converting Mega2R data to GenABEL format</h1>

<p>Mega2R provides support for converting the
data frames into &#39;GenABEL&#39; format (e.g. as gwaa.data-class objects).</p>

<p>The &#39;GenABEL&#39; package is available on CRAN as (<a href="https://CRAN.R-project.org/package=GenABEL">https://CRAN.R-project.org/package=GenABEL</a>).
The reference is 
[Aulchenko Y.S., Ripke S., Isaacs A., van Duijn C.M. GenABEL: an R package for genome-wide association analysis. Bioinformatics. 2007 23(10):1294-6.]</p>

<h2>9.1 Creating a GenABEL gwaa.data-class object using Mega2R</h2>

<p>There are several data formats that Mega2 can read and transform
into a database that are not directly accepted by GenABEL. But any
Mega2 database that can be read into R, can be transformed to GenABEL
following this example using <em>seqsimr.db</em>.</p>

<p>GenABEL (<a href="http://www.genabel.org/">http://www.genabel.org/</a>) can process PLINK .tped/.tfam files with the function
<code>convert.snp.tped</code> to create a GenABEL &ldquo;raw&rdquo; file.
Then the &ldquo;raw&rdquo; file and a generated phenotype
file can be processed by the function, <code>load.gwaa.data</code>, to yield a gwaa.data-class
object.
Currently, the function, <code>Mega2GenABEL</code>, 
uses this mechanism to convert Mega2 data frames to a gwaa.data-class
object.
The .tped/.fam/.phe files are created in a scratch space, file.path(tempdir(), Mega2GenABEL).
They are deleted when the <code>Mega2GenABEL</code> function exits. The
GenABEL functions <code>convert.snp.tped</code> and <code>load.gwaa.data</code> are explained in
<a href="https://cran.r-project.org/package=GenABEL">https://cran.r-project.org/package=GenABEL</a>.</p>

<p>If you haven&#39;t already, first install the &#39;GenABEL&#39; package from CRAN.</p>

<p>Then type:</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = read.Mega2DB(db)

# This line converts the database to a gwaa.data-class object. The intermediate
# files are in tempdir() and begin with &#39;Mega2GenABEL&#39;
seqsimgwaa = Mega2GenABEL()
</code></pre>

<pre><code>## Reading individual ids from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tfam&#39; ...
## ... done.  Read 1380 individual ids from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tfam&#39;
## Reading genotypes from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tped&#39; ...
## ...done.  Read 1000 SNPs from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tped&#39;
## Writing to file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABELtped.raw&#39; ...
## ... done.
## ids loaded...
## marker names loaded...
## chromosome data loaded...
## map data loaded...
## allele coding data loaded...
## strand data loaded...
## genotype data loaded...
## snp.data object created...
## assignment of gwaa.data object FORCED; X-errors were not checked!
</code></pre>

<p>You can use any of the GenABEL provided functions on the results, <code>seqsimgwaa</code>.</p>

<pre><code class="r">str(seqsimgwaa)
</code></pre>

<pre><code>## Formal class &#39;gwaa.data&#39; [package &quot;GenABEL&quot;] with 2 slots
##   ..@ phdata:&#39;data.frame&#39;:   1380 obs. of  3 variables:
##   .. ..$ id     : chr [1:1380] &quot;1SAP039_H05-0107&quot; &quot;1SAP039_H05-0106&quot; &quot;1SAP039_SAP039F14&quot; &quot;1SAP039_SAP039F13&quot; ...
##   .. ..$ sex    : int [1:1380] 0 1 1 1 1 0 0 0 0 0 ...
##   .. ..$ default: int [1:1380] 1 1 1 1 1 1 1 1 1 1 ...
##   ..@ gtdata:Formal class &#39;snp.data&#39; [package &quot;GenABEL&quot;] with 11 slots
##   .. .. ..@ nbytes    : num 345
##   .. .. ..@ nids      : int 1380
##   .. .. ..@ nsnps     : int 1000
##   .. .. ..@ idnames   : chr [1:1380] &quot;1SAP039_H05-0107&quot; &quot;1SAP039_H05-0106&quot; &quot;1SAP039_SAP039F14&quot; &quot;1SAP039_SAP039F13&quot; ...
##   .. .. ..@ snpnames  : chr [1:1000] &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; &quot;snp4&quot; ...
##   .. .. ..@ chromosome: Factor w/ 1 level &quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:1000] &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; &quot;snp4&quot; ...
##   .. .. ..@ map       : Named num [1:1000] 2 3 4 5 201 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:1000] &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; &quot;snp4&quot; ...
##   .. .. ..@ coding    :Formal class &#39;snp.coding&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:1000] 01 01 01 01 ...
##   .. .. ..@ strand    :Formal class &#39;snp.strand&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:1000] 00 00 00 00 ...
##   .. .. ..@ male      : Named int [1:1380] 0 1 1 1 1 0 0 0 0 0 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:1380] &quot;1SAP039_H05-0107&quot; &quot;1SAP039_H05-0106&quot; &quot;1SAP039_SAP039F14&quot; &quot;1SAP039_SAP039F13&quot; ...
##   .. .. ..@ gtps      :Formal class &#39;snp.mx&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:345, 1:1000] 59 55 55 55 ...
</code></pre>

<h1>10 Regression testing</h1>

<p>To verify that the functions described above have worked correctly,
we can compare their output files to those created by Mega2, itself, to
verify that they are identical, as expected. This type of testing is
known as regression testing.</p>

<h2>10.1 VCF regression</h2>

<p>If you have a executable copy of Mega2, you can run the code below using
the MEGA2.BATCH.vcf file and provided example database.</p>

<p>Cut and paste the shell code and you should see similar results to what
is presented here.</p>

<p>Otherwise, the text below is an illustration of what should happen.
These lines use the C++ Mega2 program to populate the <em>vcf</em> directory with
the same set of files that the were created in the <em>vcfr</em>
directory.  </p>

<p>At the Unix command prompt in the temporary directory with the name given by <code>where_mega2rtutorial_data()</code>, type:</p>

<pre><code class="bash">mkdir vcf
mega2 MEGA2.BATCH.vcf
</code></pre>

<p><strong>Note: To make this tutorial only dependent on R, the above code is not actually run.  And the
results, shown below, were captured from an environment where we had both R and the Mega2
executable available.</strong></p>

<p>The output should be similar to that below (except for time stamps):</p>

<pre><code>## ==========================================================
##                           MEGA2 4.9.2
##
##      Copyright 1999-2017, University of Pittsburgh. All Rights Reserved.
##
##      Contributors to Mega2: Robert Baron, Justin R. Stickel, Charles P. Kollar, 
##      Nandita Mukhopadhyay, Lee Almasy, Mark Schroeder, William P. Mulvihill, 
##      and Daniel E. Weeks. 
## 
##      Last updated: Jun 13 2017, 09:36:42 , valid until June 15, 2018.
##      Compiled with gcc version 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)
## 
##      Mega2 comes with ABSOLUTELY NO WARRANTY.
##      See LICENSE.txt for terms of copying, modifying &amp; redistributing Mega2.
## ==========================================================
## NOTE: For humans, chromosome 23 codes for X, 24 codes for Y and 25 codes for XY.
## 
## Run date:                  2017-7-24-10-05
## 
## Running Mega2 in batch mode from MEGA2.BATCH.vcf.
## Analysis option read in from batch file.
## Chromosome(s) and markers read in from batch file.
## Trait selection(s) read in from batch file.
## ==========================================================
## Analysis Class: VCF.
## Quantitative Output Missing Value     &quot;-9&quot;
## Affection    Output Missing Value     &quot;-9&quot;
## Reading SQLite3 DB from file &quot;seqsimr.db&quot;
## ===========================================================
## The path to this SQLite3 database is seqsimr.db.
## This database was created using Mega2 version 4.9.2.
## This database was created using   SQLite3 3.9.2 on 2017-7-24-10-03.
## This database was processed using SQLite3 3.9.2 on 2017-7-24-10-05.
## This database was created from PLINK PED format data using the following files:
##         Pedigree file   Mega2r.ped
##        PLINK Map file   Mega2r.map
## This database contains:
##  1380 persons (20 pedigrees)
##  1000 markers
##  1 trait
##  genetic distance(map name/type) &quot;Map&quot;/kosambi, Sex map type AVERAGED_MAP
##  base pair distance(map name) &quot;BP&quot;
## 
## ==========================================================
## 1 trait locus 
##       1 Affection status locus: 
##                 default
## ===========================================================
## Selected map Map.
## Selected chromosome 1
## Output will combine markers and the following selected traits:
##                 default [MARKERS]
## After selecting traits and covariates
## 1 trait locus 
##       1 Affection status locus: 
##                 default
## ===========================================================
## Pedigree statistics after selecting chromosomes and marker loci:
## Input pedigree file is in post-makeped format.
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Mega2 created the following file(s) for VCF Format:
## VCF file created using allele ordering setting: Original_Order
##         VCF format file:        vcf/vcf.01.vcf
##         VCF pedigree file:      vcf/vcf.01.fam
##         VCF phenotype file:     vcf/vcf.01.phe
##         VCF map file:           vcf/vcf.01.map
##         VCF freq file:          vcf/vcf.01.freq
##         VCF pen file:           vcf/vcf.01.pen
## 
## SQLite3 database &quot;seqsimr.db&quot; was processed to generate this output.
## Output is in vcf
## ===========================================================
## See run summaries in directory 2017-7-24-10-05 
##    MEGA2.LOG, MEGA2.ERR, MEGA2.KEYS
## The script &#39;mega2log2html.pl&#39; exited normally.
## To view the HTML-formatted run summaries, open
## /Users/rbaron/mega2/bb/srcdir/R/mega2rtutorial/vignettes/2017-7-24-10-05/MEGA2run.html
## in a web browser.
## ===========================================================
## If you use Mega2 as part of a published work, please reference 
##  Baron RV, Kollar C, Mukhopadhyay N, Weeks DE
##  Mega2: validated data-reformatting for linkage and association analyses
##  Source Code for Biology and Medicine.2014, 9:26
##  DOI: 10.1186/s13029-014-0026-y
## as well as the version used, which is currently Version 4.9.2
## ===========================================================
</code></pre>

<p>The abbreviated MEGA2.BATCH.vcf file is below. (The initial comment section
is not shown and important lines are shown in a bold typeface.)
Notice that there are no INPUT FILES, just a database file.</p>

<blockquote>
<p>Input_Database_Mode=2<br/>
Align_Strand_Input=no<br/>
<strong>Output_Path=vcf</strong><br/>
Input_Untyped_Ped_Option=2<br/>
Input_Do_Error_Sim=no<br/>
AlleleFreq_SquaredDev=999999999.000000<br/>
<strong>Analysis_Option=VCF</strong><br/>
Value_Missing_Quant_On_Output=-9<br/>
Value_Missing_Affect_On_Output=-9<br/>
<strong>DBfile_name=seqsimr.db</strong><br/>
Chromosome_Single=1<br/>
Traits_Combine=1 2 e<br/>
<strong>file_name_stem=vcf</strong><br/>
human_genome_build=B37<br/>
VCF_output_file_type=1<br/>
VCF_Allele_Order=Original_Order<br/>
Default_Outfile_Names=yes  </p>
</blockquote>

<p>You should compare the two directories: <em>vcf</em> and <em>vcfr</em>. Please add the
-w flag to the diff command. This causes the comparison to ignore
differences in white space.  Lines that
contain dates may be different between the two directories.
At the Unix command prompt in the temporary directory, with the name given by <code>where_mega2rtutorial_data()</code>, type:</p>

<pre><code class="bash">diff -wrs vcf vcfr
</code></pre>

<p><strong>Note: To make this tutorial only dependent on R, the above code is not actually run.  And the
results, shown below, were captured from an environment where we had both R and the Mega2
executable available.</strong></p>

<p>The <em>diff</em> should show:</p>

<pre><code>## Files vcf/vcf.01.fam and vcfr/vcf.01.fam are identical
## Files vcf/vcf.01.freq and vcfr/vcf.01.freq are identical
## Files vcf/vcf.01.map and vcfr/vcf.01.map are identical
## Files vcf/vcf.01.pen and vcfr/vcf.01.pen are identical
## Files vcf/vcf.01.phe and vcfr/vcf.01.phe are identical
## Files vcf/vcf.01.vcf and vcfr/vcf.01.vcf are identical
</code></pre>

<h2>10.2 GenABEL regression</h2>

<p>This test is a bit more complicated.
We intend to verify that the object generated 
by <code>Mega2GenABEL</code> is the same as a GenABEL object we started with.
First, we load <code>GenABEL</code> and access its data:</p>

<pre><code class="r">library(GenABEL)
data(srdta)
</code></pre>

<p>Then we dump the GenABEL data as
PLINK .ped/.map/.phe files</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
srdtafile = file.path(where_mega2rtutorial_data(), &quot;srdta&quot;)
export.plink(srdta, transpose = FALSE, filebasename = srdtafile, phenotypes = names(srdta@phdata)[-(1:2)])
</code></pre>

<p>To produce the Mega2 database <code>srdta.db</code>, we switch to the Unix command line, cd to 
the temporary directory, with the name given by the results of this R command <code>where_mega2rtutorial_data()</code>, and run:</p>

<pre><code class="bash">mega2 MEGA2.BATCH.srdta
</code></pre>

<p><strong>NOTE: To make this tutorial only dependent on R, the above code is not actually run.  And its
results, shown below, were captured from an environment where we had both R and the Mega2 executable
available.</strong></p>

<pre><code>## ==========================================================
##                           MEGA2 4.9.2
##      Copyright 1999-2017, University of Pittsburgh. All Rights Reserved.
##      Contributors to Mega2: Robert Baron, Justin R. Stickel, Charles P. Kollar,
##      Nandita Mukhopadhyay, Lee Almasy, Mark Schroeder, William P. Mulvihill,
##      and Daniel E. Weeks.
## 
##      Last updated: Oct 13 2017, 09:55:04 , valid until June 15, 2018.
##      Compiled with gcc version 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)
## 
##      Mega2 comes with ABSOLUTELY NO WARRANTY.
##      See LICENSE.txt for terms of copying, modifying &amp; redistributing Mega2.
## ==========================================================
## NOTE: For humans, chromosome 23 codes for X, 24 codes for Y and 25 codes for XY.
## 
## Run date:                  2017-10-13-10-06
## 
## Running Mega2 in batch mode from MEGA2.BATCH.srdta.
## Input filenames and missing value indicator read in from batch file.
## Dump Analysis option read in from batch file.
## WARNING: Locus selections not specified in batch file.
## WARNING: Going to Reorder menu.
## WARNING: Trait selections not specified in batch file.
## WARNING: Going to Trait selection menu.
## ==========================================================
## Keyword Input_Locus_File not in batch file, Locus file assumed to be unspecified.
## Keyword Input_Map_File not in batch file, Map file assumed to be unspecified.
## Keyword Input_Omit_File not in batch file, Omit file assumed to be unspecified.
## Keyword Input_Frequency_File not in batch file, Frequency file assumed to be unspecified.
## Keyword Input_Penetrance_File not in batch file, Penetrance file assumed to be unspecified.
## Keyword Input_Aux_File not in batch file, Aux file assumed to be unspecified.
## Keyword Input_Imputed_Info_File not in batch file, Imputed Info file assumed to be unspecified.
## ===========================================================
## Analysis Class: Dump.
## Quantitative  Input Missing Value  -9 
## Affection     Input Missing Value     &quot;-9&quot;
## Quantitative Output Missing Value      &quot;*&quot;
## Affection    Output Missing Value      &quot;*&quot;
## Input Format: PLINK PED format (ped)
## Pedigree and map files specified as PLINK format.
## omit, penetrance, and frequency files are always in Mega2 format.
## Input files will be read in as PLINK or Mega2 format files as appropriate.
## reading phenotype file srdta.phe ... (5 columns)
## Reading PLINK map file for names: srdta.map
## Reading map file srdta.map ... (4 columns)
## Input Map name: Map, type: average genetic map, units: kosambi Morgans
## Input Map name: BP, type: physical map
## Found 2 possible maps in the srdta.map file.
## Now checking each record in map file srdta.map ...
## Done reading map file: srdta.map
## 
## ===========================================================
## Total number of loci =  839
## 6 trait loci 
##       2 Affection status loci: 
##                 bt default
##       4 Quantitative loci: 
##                 age qt1 qt2 qt3
##       833 Marker loci 
## Number of loci found per chromosome (chromosome:number)
##    1:833
## ===========================================================
## WARNING: No frequency file provided.
## WARNING: Allele frequencies for these will be estimated from data.
## Trait &#39;bt&#39; will be assigned the default penetrance: (0.0500 0.9000 0.9000)
## Trait &#39;default&#39; will be assigned the default penetrance: (0.0500 0.9000 0.9000)
## Reading PLINK .ped file: srdta.ped (1672 columns).
## 833 (of 833) markers to be included from srdta.map
## Reading pedigree information from srdta.ped
## 2500 individuals read from srdta.ped
## 2500 individuals with nonmissing phenotypes
## 0 cases, 0 controls, 2500 missing
## 1275 males, 1225 females, 0 of unspecified sex
## 0 founders, 2500 non-founders found
## ===========================================================
## Input pedigree data contains:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL     2500     2500    1275      1225       1978958        0    2082500
## Typed     2500     2500    1275      1225
## Untyped      0        0       0         0
## ===========================================================
## Pedigree exclusion option : Include all pedigrees whether typed or not.
## Count option: all alleles
## Count half-typed individuals&#39; alleles : no 
## ===========================================================
## Recoding pedigree genotypes ... 
## ===========================================================
## Pedigree data summary after recoding:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL     2500     2500    1275      1225       1978958        0    2082500
## Typed     2500     2500    1275      1225
## Untyped      0        0       0         0
## ===========================================================
## Created linkage ped tree
## 
## ===== Messages of type &quot;quant_stat&quot;: 
## ------------------------------------------------------------
## Per-pedigree quantitative phenotype summary:
## Pedigree     Mean      Std Dev     Minimum    Maximum  #Phenotypes
## ------------------------------------------------------------
## age
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1            43.40000    0.00000   43.40000   43.40000        1
## 2            48.20000    0.00000   48.20000   48.20000        1
## 3            37.90000    0.00000   37.90000   37.90000        1
## 4            53.80000    0.00000   53.80000   53.80000        1
## 5            47.50000    0.00000   47.50000   47.50000        1
## 6            45.00000    0.00000   45.00000   45.00000        1
## 7            52.00000    0.00000   52.00000   52.00000        1
## 8            42.50000    0.00000   42.50000   42.50000        1
## 9            29.70000    0.00000   29.70000   29.70000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## qt1
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1            -0.58000    0.00000   -0.58000   -0.58000        1
## 2             0.80000    0.00000    0.80000    0.80000        1
## 3            -0.52000    0.00000   -0.52000   -0.52000        1
## 4            -1.55000    0.00000   -1.55000   -1.55000        1
## 5             0.25000    0.00000    0.25000    0.25000        1
## 6             0.15000    0.00000    0.15000    0.15000        1
## 7            -0.56000    0.00000   -0.56000   -0.56000        1
## 8             0.00000    0.00000    0.00000    0.00000        0
## 9            -2.26000    0.00000   -2.26000   -2.26000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## qt2
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1             4.46000    0.00000    4.46000    4.46000        1
## 2             6.32000    0.00000    6.32000    6.32000        1
## 3             3.26000    0.00000    3.26000    3.26000        1
## 4           888.00000    0.00000  888.00000  888.00000        1
## 5             5.70000    0.00000    5.70000    5.70000        1
## 6             4.65000    0.00000    4.65000    4.65000        1
## 7             4.64000    0.00000    4.64000    4.64000        1
## 8             5.77000    0.00000    5.77000    5.77000        1
## 9             0.71000    0.00000    0.71000    0.71000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## qt3
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1             1.43000    0.00000    1.43000    1.43000        1
## 2             3.90000    0.00000    3.90000    3.90000        1
## 3             5.05000    0.00000    5.05000    5.05000        1
## 4             3.76000    0.00000    3.76000    3.76000        1
## 5             2.89000    0.00000    2.89000    2.89000        1
## 6             1.87000    0.00000    1.87000    1.87000        1
## 7             2.49000    0.00000    2.49000    2.49000        1
## 8             2.68000    0.00000    2.68000    2.68000        1
## 9             1.45000    0.00000    1.45000    1.45000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## ===== 2501 total records of type &quot;quant_stat&quot; are in MEGA2.LOG
## 
## 
## ===== Messages of type &quot;quant_stat_sum&quot;: 
##                Quantitative trait phenotype statistics
## -------------------------------------------------------------------------------
## QTL            Missing  Minimum   Maximum   Total      Pedigrees    Total
##                                             pedigrees  phenotyped   phenotypes
## -------------------------------------------------------------------------------
## age                  0   24.100    71.600        2500        2500         2500
## qt1                  3   -4.600     3.200        2500        2497         2497
## qt2                  0    0.000   888.000        2500        2500         2500
## qt3                 11   -1.970     6.340        2500        2489         2489
## NOTE: The Missing QTL value on input has been assigned as &#39;-9.00&#39;.
## -------------------------------------------------------------------------
## QTL                 Mean   Std Dev  Skewness  Kurtosis
## -------------------------------------------------------------------------
## age               50.038     7.060     0.003    -0.063
## qt1               -0.298     1.001    -0.075     0.126
## qt2                6.122    30.601    28.734   825.077
## qt3                2.609     1.101     0.033    -0.090
## ===========================================================
## ===== 4 total records of type &quot;quant_stat_sum&quot; are in MEGA2.LOG
## 
## Done checking locus integrity.
## Checking pedigree integrity...
## Done checking pedigree integrity.
## ==========================================================
## ===========================================================
## Pedigree statistics after selecting chromosomes and marker loci:
## Input pedigree file is in post-makeped format.
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL     2500     2500    1275      1225       1978958        0    2082500
## Typed     2500     2500    1275      1225
## Untyped      0        0       0         0
## ===========================================================
## Database file &quot;srdta.db&quot; will be backed up.
## Moved existing srdta.db to srdta.db.old
## Dumping SQLite3 DB to file &quot;srdta.db&quot;
## ===========================================================
## See run summaries in directory 2017-10-13-10-06 
##    MEGA2.LOG, MEGA2.RECODE, MEGA2.ERR, MEGA2.KEYS
## The script &#39;mega2log2html.pl&#39; exited normally.
## To view the HTML-formatted run summaries, open
## /Users/rbaron/mega2/bb/srcdir/R/2017-10-13-10-06/MEGA2run.html
## in a web browser.
## ===========================================================
</code></pre>

<h3>The MEGA2.BATCH.srdata file</h3>

<p>The abbreviated MEGA2.BATCH.srdta file is below. (The initial comment section
is not shown and important lines are shown in a bold typeface.)</p>

<blockquote>
<p><strong>Input_Database_Mode=1</strong><br/>
<strong>Input_Format_Type=4</strong><br/>
<strong>Input_Pedigree_File=srdta.ped</strong><br/>
<strong>Input_PLINK_Map_File=srdta.map</strong><br/>
<strong>Input_Phenotype_File=srdta.phe</strong><br/>
Output_Path=.<br/>
Input_Path=.<br/>
PLINK_Args= &ndash;missing-phenotype -9 &ndash;trait default<br/>
Input_Untyped_Ped_Option=2<br/>
Input_Do_Error_Sim=no<br/>
AlleleFreq_SquaredDev=999999999.000000<br/>
Value_Marker_Compression=1<br/>
<strong>Analysis_Option=Dump</strong><br/>
Value_Missing_Quant_On_Input=-9.000000<br/>
Value_Missing_Affect_On_Input=-9<br/>
Count_Genotypes=4<br/>
Count_Halftyped=no<br/>
Value_Genetic_Distance_Index=0<br/>
Value_Genetic_Distance_SexTypeMap=0<br/>
Value_Base_Pair_Position_Index=1<br/>
Default_Reset_Invalid=no<br/>
<strong>DBfile_name=srdta.db</strong><br/>
Default_Outfile_Names=yes  </p>
</blockquote>

<p>Note: We have provided a copy of the srdta.db database in the Mega2R package.  So
you can proceed with the steps that follow, even if you did not create your own database.</p>

<p>Now, we go back into R and type:</p>

<pre><code class="r"># Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.
sdb = file.path(where_mega2rtutorial_data(), &quot;srdta.db&quot;)
ENV = read.Mega2DB(sdb)

mega = Mega2GenABEL()
</code></pre>

<pre><code>## Reading individual ids from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tfam&#39; ...
## ... done.  Read 2500 individual ids from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tfam&#39;
## Reading genotypes from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tped&#39; ...
## ...done.  Read 833 SNPs from file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABEL.tped&#39;
## Writing to file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpmeEeXX/Mega2GenABELtped.raw&#39; ...
## ... done.
## ids loaded...
## marker names loaded...
## chromosome data loaded...
## map data loaded...
## allele coding data loaded...
## strand data loaded...
## genotype data loaded...
## snp.data object created...
## assignment of gwaa.data object FORCED; X-errors were not checked!
</code></pre>

<p><code>mega</code> should be the same as the <code>srdta</code> gwaa.data-class object. You can
compare them however you prefer.    For example, in R, type:</p>

<pre><code class="r">str(mega)
</code></pre>

<pre><code>## Formal class &#39;gwaa.data&#39; [package &quot;GenABEL&quot;] with 2 slots
##   ..@ phdata:&#39;data.frame&#39;:   2500 obs. of  8 variables:
##   .. ..$ id     : chr [1:2500] &quot;1_p1&quot; &quot;2_p2&quot; &quot;3_p3&quot; &quot;4_p4&quot; ...
##   .. ..$ sex    : int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. ..$ age    : num [1:2500] 43.4 48.2 37.9 53.8 47.5 45 52 42.5 29.7 45.8 ...
##   .. ..$ qt1    : num [1:2500] -0.58 0.8 -0.52 -1.55 0.25 0.15 -0.56 -9 -2.26 -1.32 ...
##   .. ..$ qt2    : num [1:2500] 4.46 6.32 3.26 888 5.7 4.65 4.64 5.77 0.71 3.26 ...
##   .. ..$ qt3    : num [1:2500] 1.43 3.9 5.05 3.76 2.89 1.87 2.49 2.68 1.45 0.85 ...
##   .. ..$ bt     : int [1:2500] 0 1 1 1 1 0 0 1 0 0 ...
##   .. ..$ default: int [1:2500] 0 0 0 0 0 0 0 0 0 0 ...
##   ..@ gtdata:Formal class &#39;snp.data&#39; [package &quot;GenABEL&quot;] with 11 slots
##   .. .. ..@ nbytes    : num 625
##   .. .. ..@ nids      : int 2500
##   .. .. ..@ nsnps     : int 833
##   .. .. ..@ idnames   : chr [1:2500] &quot;1_p1&quot; &quot;2_p2&quot; &quot;3_p3&quot; &quot;4_p4&quot; ...
##   .. .. ..@ snpnames  : chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ chromosome: Factor w/ 1 level &quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ map       : Named num [1:833] 2500 3500 5750 13500 14250 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ coding    :Formal class &#39;snp.coding&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 08 0b 0c 07 ...
##   .. .. ..@ strand    :Formal class &#39;snp.strand&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 00 00 00 00 ...
##   .. .. ..@ male      : Named int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2500] &quot;1_p1&quot; &quot;2_p2&quot; &quot;3_p3&quot; &quot;4_p4&quot; ...
##   .. .. ..@ gtps      :Formal class &#39;snp.mx&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:625, 1:833] 55 59 55 a5 ...
</code></pre>

<pre><code class="r">str(srdta)
</code></pre>

<pre><code>## Formal class &#39;gwaa.data&#39; [package &quot;GenABEL&quot;] with 2 slots
##   ..@ phdata:&#39;data.frame&#39;:   2500 obs. of  7 variables:
##   .. ..$ id : chr [1:2500] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; ...
##   .. ..$ sex: int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. ..$ age: num [1:2500] 43.4 48.2 37.9 53.8 47.5 45 52 42.5 29.7 45.8 ...
##   .. ..$ qt1: num [1:2500] -0.58 0.8 -0.52 -1.55 0.25 0.15 -0.56 NA -2.26 -1.32 ...
##   .. ..$ qt2: num [1:2500] 4.46 6.32 3.26 888 5.7 4.65 4.64 5.77 0.71 3.26 ...
##   .. ..$ qt3: num [1:2500] 1.43 3.9 5.05 3.76 2.89 1.87 2.49 2.68 1.45 0.85 ...
##   .. ..$ bt : int [1:2500] 0 1 1 1 1 0 0 1 0 0 ...
##   ..@ gtdata:Formal class &#39;snp.data&#39; [package &quot;GenABEL&quot;] with 11 slots
##   .. .. ..@ nbytes    : num 625
##   .. .. ..@ nids      : int 2500
##   .. .. ..@ nsnps     : int 833
##   .. .. ..@ idnames   : chr [1:2500] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; ...
##   .. .. ..@ snpnames  : chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ chromosome: Factor w/ 1 level &quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ map       : Named num [1:833] 2500 3500 5750 13500 14250 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ coding    :Formal class &#39;snp.coding&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 08 0b 0c 03 ...
##   .. .. ..@ strand    :Formal class &#39;snp.strand&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 01 01 02 01 ...
##   .. .. ..@ male      : Named int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2500] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; ...
##   .. .. ..@ gtps      :Formal class &#39;snp.mx&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:625, 1:833] 55 59 55 a5 ...
</code></pre>

<p>You can compare these printouts by eye.  Alternatively, 
the function <em>Mega2GenABELtst()</em> can be used to
compare the phenotype data, genotype data, and object metadata, item by item.</p>

<pre><code class="r">options(max.print = 30)
Mega2GenABELtst(mega_ = mega, gwaa_ = srdta)
</code></pre>

<pre><code>## all(mega_@phdata$sex == gwaa_@phdata$sex) [1] TRUE
## all(mega_@phdata$age == gwaa_@phdata$age) [1] TRUE
## all(mega_@phdata$qt1 == gwaa_@phdata$qt1) [1] TRUE
## all(mega_@phdata$qt2 == gwaa_@phdata$qt2) [1] TRUE
## all(mega_@phdata$qt3 == gwaa_@phdata$qt3) [1] TRUE
## all(mega_@phdata$bt == gwaa_@phdata$bt) [1] TRUE
## all(mega_@gtdata@nids == gwaa_@gtdata@nids)[1] TRUE
## all(mega_@gtdata@nsnps == gwaa_@gtdata@nsnps)[1] TRUE
## all(mega_@gtdata@nbytes == gwaa_@gtdata@nbytes)[1] TRUE
## all(mega_@gtdata@idnames == gwaa_@gtdata@idnames)[1] FALSE
## all(mega_@gtdata@snpnames == gwaa_@gtdata@snpnames)[1] TRUE
## all(mega_@gtdata@chromosome == gwaa_@gtdata@chromosome)[1] TRUE
## all(mega_@gtdata@map == gwaa_@gtdata@map)[1] TRUE
## all(mega_@gtdata@male == gwaa_@gtdata@male)[1] TRUE
## all(mega_@gtdata@coding == gwaa_@gtdata@coding)[1] FALSE
## all(mega_@gtdata@strand == gwaa_@gtdata@strand)[1] FALSE
## all(mega_@gtdata@gtps == gwaa_@gtdata@gtps)[1] FALSE
## all(mega_@gtdata == gwaa_@gtdata)[1] TRUE
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [1] &quot;markers that differ&quot;
## [1] &quot;markers that differ&quot;
##     locus_link locus_link_fill MarkerName chromosome position
## 4            9               9       rs65          1    13500
## 8           13              13      rs130          1    27250
## 10          15              15      rs150          1    33250
## 20          25              25      rs324          1    82500
## 23          28              28      rs348          1    88000
## 24          29              29      rs361          1    90000
##  [ reached getOption(&quot;max.print&quot;) -- omitted 209 rows ]
## [1] &quot;markerscheme_table (compression) alleles that differ&quot;
## [1] &quot;markerscheme_table (compression) alleles that differ&quot;
##     pId key allele1 allele2
## 4     4   9       1       2
## 8     8  13       1       2
## 10   10  15       1       2
## 20   20  25       2       1
## 23   23  28       2       1
## 24   24  29       1       2
## 29   29  34       1       2
##  [ reached getOption(&quot;max.print&quot;) -- omitted 208 rows ]
## [1] &quot;allele values for markers that differ&quot;
## [1] &quot;allele values for markers that differ&quot;
##     locus_link pId.x AlleleName.x Frequency.x indexX.x pId.y AlleleName.y
## 4            9    19            A  0.28027754        1    20            T
## 8           13    27            A  0.30622110        1    28            G
## 10          15    31            A  0.65998312        1    32            C
##     Frequency.y indexX.y
## 4    0.71972246        2
## 8    0.69377890        2
## 10   0.34001688        2
##  [ reached getOption(&quot;max.print&quot;) -- omitted 212 rows ]
</code></pre>

<p>These results are somewhat disappointing.  But &hellip;</p>

<p>First, &ldquo;mega2&rdquo; prefers to use the pedigree id concatenated to the person id as the sample
name, even if the person id itself is unique.</p>

<p>The second difference in
<strong>gtdata\@strand</strong> occurs because Mega2 does not keep track of strand
orientation and always returns 0.  </p>

<p>The final difference is more subtle.  The <strong>gtdata</strong> comparison line
decodes the genotype to characters then normalizes the two
heterozygous cases to one value.  These results are the same for the
two different gwaa.class-objects; hence the data are really the same.  But
<code>Mega2GenABEL</code> converts the data frames using the <code>convert.snp.tped</code>
function while the <code>srdta</code> object, generated by GenABEL, uses the
<code>convert.snp.text</code>.  Though both functions encode the genotype to a
number, the <code>convert.snp.tped</code> function rearranges the genotype so
that the major allele appears first, the <code>convert.snp.text</code> does no
such rearrangement.  Because <strong>gtdata\@coding</strong> and <strong>gtdata\@gtps</strong>
compare the encoded allele pairs and corresponding encoded genotypes,
they sometimes differ.</p>

<h1>11 Next steps</h1>

<p>If you are left with questions as to how you can use Mega2R for your own research, you can:</p>

<ol>
<li><p>Read our paper &ldquo;The Mega2R R package: tools for accessing
and processing common genetic data formats in R&rdquo; (in preparation), which extends this
document by providing implementation details.</p></li>
<li><p>Read the source of the various functions if you understand R; the code is not particularly subtle.</p></li>
<li><p>Write to the Mega2 discussion group: <a href="https://groups.google.com/forum/#!forum/mega2-users">https://groups.google.com/forum/#!forum/mega2-users</a></p></li>
</ol>

<h1>12 Acknowlegements</h1>

<p>The Mega2 C++ program and this Mega2R R package are both open source and are freely available, along with extensive documentation, from our <a href="https://watson.hgen.pitt.edu/register">https://watson.hgen.pitt.edu/register</a> web site. This work was supported by NIH grant R01 GM076667 (PI: Weeks). </p>

</body>

</html>
